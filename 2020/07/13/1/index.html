<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java-日期、System类、Collection集合 | 不蒸馒头争口气</title><meta name="description" content="Object 类Object是类层次结构的父类 每个类都使用Object作为超类，包括自己定义的类 toString()方法：打印的只是对象的地址值，使用时需重写。 直接打印实例，其实就是调用了toString()方法   equals()方法：默认是“&#x3D;&#x3D;”用来比较对象的地址值，纯比较地址来说没有意义，所以需要重写，比较两个对象的属性（name，age） &#x3D;&#x3D;  基本数据类型比较的是值 引用数据"><meta name="keywords" content="Java,Collection"><meta name="author" content="laden"><meta name="copyright" content="laden"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lqhao.gitee.io/2020/07/13/1/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Java-日期、System类、Collection集合"><meta property="og:url" content="http://lqhao.gitee.io/2020/07/13/1/"><meta property="og:site_name" content="不蒸馒头争口气"><meta property="og:description" content="Object 类Object是类层次结构的父类 每个类都使用Object作为超类，包括自己定义的类 toString()方法：打印的只是对象的地址值，使用时需重写。 直接打印实例，其实就是调用了toString()方法   equals()方法：默认是“&#x3D;&#x3D;”用来比较对象的地址值，纯比较地址来说没有意义，所以需要重写，比较两个对象的属性（name，age） &#x3D;&#x3D;  基本数据类型比较的是值 引用数据"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-13T02:42:23.188Z"><meta property="article:modified_time" content="2020-07-22T13:27:38.274Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Java-异常、线程" href="http://lqhao.gitee.io/2020/07/15/1/"><link rel="next" title="Java-基本引用类型的使用" href="http://lqhao.gitee.io/2020/07/10/2/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/04232036663275.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object"><span class="toc-number">1.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日期时间类"><span class="toc-number">2.</span> <span class="toc-text">日期时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date：（java-util包）表示日期和时间的类-1000毫秒-1秒"><span class="toc-number">2.1.</span> <span class="toc-text">Date：（java.util包）表示日期和时间的类 1000毫秒&#x3D;1秒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateFormat类：-java-text包-日期格式化类，是一个抽象类，不能直接使用，要用他的子类SimpleDateFormat类"><span class="toc-number">2.2.</span> <span class="toc-text">DateFormat类：(java.text包)日期格式化类，是一个抽象类，不能直接使用，要用他的子类SimpleDateFormat类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar-（java-util包）日历类，抽象类，但是提供了getInstance-静态方法，该方法直接返回对象Calender类的子类对象"><span class="toc-number">2.3.</span> <span class="toc-text">Calendar （java.util包）日历类，抽象类，但是提供了getInstance()静态方法，该方法直接返回对象Calender类的子类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#综合练习题"><span class="toc-number">2.4.</span> <span class="toc-text">综合练习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System类"><span class="toc-number">3.</span> <span class="toc-text">System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBulider"><span class="toc-number">4.</span> <span class="toc-text">StringBulider</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包装类"><span class="toc-number">5.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#装箱与拆箱"><span class="toc-number">5.1.</span> <span class="toc-text">装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装箱与自动拆箱"><span class="toc-number">5.2.</span> <span class="toc-text">自动装箱与自动拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型与字符串类型直接的相互转换"><span class="toc-number">5.3.</span> <span class="toc-text">基本类型与字符串类型直接的相互转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection集合"><span class="toc-number">6.</span> <span class="toc-text">Collection集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#collection常用功能"><span class="toc-number">6.1.</span> <span class="toc-text">collection常用功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-lt-gt-接口-迭代器-通用的取出元素的方式"><span class="toc-number">6.2.</span> <span class="toc-text">Iterator&lt;&gt;接口 (迭代器) :  通用的取出元素的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增强for循环-foreach-专门用来遍历集合跟数组"><span class="toc-number">6.3.</span> <span class="toc-text">增强for循环(foreach):专门用来遍历集合跟数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型"><span class="toc-number">6.4.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建集合对象使用泛型"><span class="toc-number">6.5.</span> <span class="toc-text">创建集合对象使用泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义含有泛型的类"><span class="toc-number">6.6.</span> <span class="toc-text">自定义含有泛型的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#含有泛型的方法"><span class="toc-number">6.7.</span> <span class="toc-text">含有泛型的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#含有泛型的接口"><span class="toc-number">6.8.</span> <span class="toc-text">含有泛型的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的通配符-lt-gt-泛型不确定是可以使用通配符-但是一旦使用泛型的通配符后-只能使用Object类中的共性方法-集合中元素自身方法无法使用"><span class="toc-number">6.9.</span> <span class="toc-text">泛型的通配符 &lt;?&gt; : 泛型不确定是可以使用通配符   ,但是一旦使用泛型的通配符后,只能使用Object类中的共性方法,集合中元素自身方法无法使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection综合案例-斗地主"><span class="toc-number">6.10.</span> <span class="toc-text">collection综合案例(斗地主)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List集合接口-extends-Collection"><span class="toc-number">6.11.</span> <span class="toc-text">List集合接口 extends Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set集合接口-extends-Collection"><span class="toc-number">6.12.</span> <span class="toc-text">Set集合接口 extends Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-实现类"><span class="toc-number">6.12.1.</span> <span class="toc-text">HashSet 实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashset集合-extends-HashSet"><span class="toc-number">6.12.2.</span> <span class="toc-text">LinkedHashset集合  extends HashSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变参数"><span class="toc-number">6.13.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections集合"><span class="toc-number">7.</span> <span class="toc-text">Collections集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map集合"><span class="toc-number">8.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的实现类"><span class="toc-number">8.1.</span> <span class="toc-text">常用的实现类</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">不蒸馒头争口气</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java-日期、System类、Collection集合</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-13 10:42:23"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-22 21:27:38"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-22</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">10k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 39 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li>类Object是类层次结构的父类</li>
<li>每个类都使用Object作为超类，包括自己定义的类</li>
<li>toString()方法：打印的只是对象的地址值，使用时需重写。<ul>
<li>直接打印实例，其实就是调用了toString()方法</li>
</ul>
</li>
<li>equals()方法：默认是“==”用来比较对象的地址值，纯比较地址来说没有意义，所以需要重写，比较两个对象的属性（name，age）<ul>
<li><strong>==</strong> <ul>
<li><strong>基本数据类型比较的是值</strong></li>
<li><strong>引用数据类型比较的是地址值</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><ul>
<li><h3 id="Date：（java-util包）表示日期和时间的类-1000毫秒-1秒"><a href="#Date：（java-util包）表示日期和时间的类-1000毫秒-1秒" class="headerlink" title="Date：（java.util包）表示日期和时间的类 1000毫秒=1秒"></a>Date：（java.util包）表示日期和时间的类 1000毫秒=1秒</h3><ul>
<li>毫秒值的作用：可以对时间和日期进行计算</li>
<li>时间原点 1970年1月1日 00：00：00  英国格林尼治时间</li>
<li>System.currentTimeMillis();计算当前系统时间到时间原点经历了多少毫秒<ul>
<li>注意：中国属于东八区，会把时间增加8个小时 1970年1月1日 08：00：00  </li>
</ul>
</li>
<li>构造方法<ul>
<li>空参Date() ：获取系统的日期时间</li>
<li>带参Date(long date):  传递毫秒值，把毫秒值转换为日期</li>
</ul>
</li>
<li>成员方法<ul>
<li>getTime（）：返回从原点时间到当前时间的毫秒值，相当于System.currentTimeMillis();</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="DateFormat类：-java-text包-日期格式化类，是一个抽象类，不能直接使用，要用他的子类SimpleDateFormat类"><a href="#DateFormat类：-java-text包-日期格式化类，是一个抽象类，不能直接使用，要用他的子类SimpleDateFormat类" class="headerlink" title="DateFormat类：(java.text包)日期格式化类，是一个抽象类，不能直接使用，要用他的子类SimpleDateFormat类"></a>DateFormat类：(java.text包)<strong>日期格式化类</strong>，是一个抽象类，不能直接使用，<strong>要用他的子类SimpleDateFormat类</strong></h3><ul>
<li>成员方法<ul>
<li>String format（Date date）将一个 Date 格式化为日期/时间字符串。</li>
<li>Date parse(String source)   把符合构造方法中模式的字符串，解析生成一个日期。<ul>
<li>会有  ParseException  异常，如果字符串跟构造方法中不一样，程序就会抛出异常。</li>
</ul>
</li>
</ul>
</li>
<li>SimpleDateFormat类<ul>
<li>构造方法<ul>
<li>SimpleDateFormat(String pattern)   用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。y 年  M  月  d  日  H  时   m  分   s  秒</li>
<li>“yyyy-MM-dd HH:mm:ss”   模式中的字母不能改，连接模式的符号可以改</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Calendar-（java-util包）日历类，抽象类，但是提供了getInstance-静态方法，该方法直接返回对象Calender类的子类对象"><a href="#Calendar-（java-util包）日历类，抽象类，但是提供了getInstance-静态方法，该方法直接返回对象Calender类的子类对象" class="headerlink" title="Calendar （java.util包）日历类，抽象类，但是提供了getInstance()静态方法，该方法直接返回对象Calender类的子类对象"></a>Calendar （java.util包）日历类，抽象类，但是提供了getInstance()静态方法，该方法直接返回对象Calender类的子类对象</h3><ul>
<li>Calendar calendar = Calendar.getInstance();  //多态</li>
<li>提供了很多操作日历字段的方法  YEAR MOUTH DAY<ul>
<li>public static final int YERA</li>
<li>public static final int MONTH   （西方月份0-11  东方月份1-12）</li>
</ul>
</li>
<li>成员方法 <ul>
<li>int get (int field） ：返回给定日历字段的值  field指日历类的字段可以使用静态变量来获取</li>
<li>void set（int field ， int value）：将给定的日历字段设置为给定值   value给指定字段设置的值  </li>
<li>absteact void add（int field ， int amount）：根据日历的规则，为指定的日历字段添加或减去指定的时间量</li>
<li>Date gettime() ：返回一个表示Calendar时间值（从历元到现在的毫秒偏移量）的Date对象</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="综合练习题"><a href="#综合练习题" class="headerlink" title="综合练习题"></a>综合练习题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*                       计算一个人出生了多少天</span></span><br><span class="line"><span class="comment"> * Scanner获取出生日期</span></span><br><span class="line"><span class="comment"> * 使用DateFormat类中的方法parse，把字符串的出生日期，转换为Date格式的出生日期</span></span><br><span class="line"><span class="comment"> * 把Date格式的出生日期转换为毫秒值</span></span><br><span class="line"><span class="comment"> * 获取当前的日期转换为毫秒值</span></span><br><span class="line"><span class="comment"> * 两值相减得到出生了多少毫秒值</span></span><br><span class="line"><span class="comment"> * 把毫秒差值转换为天 （s/100/60/24）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"格式 yyyy-mm-dd"</span>);</span><br><span class="line">        String birthdayString = scanner.next();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        Date birthdayDate = simpleDateFormat.parse(birthdayString);<span class="comment">//此处需抛异常</span></span><br><span class="line">        System.out.println(<span class="string">"出生日期"</span> + birthdayDate);</span><br><span class="line">        <span class="keyword">long</span> birthdayss = birthdayDate.getTime();</span><br><span class="line">        Date today = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"现在时间"</span> + today);</span><br><span class="line">        <span class="keyword">long</span> now = today.getTime();</span><br><span class="line">        <span class="keyword">long</span> ss = now - birthdayss;</span><br><span class="line">        System.out.println(<span class="string">"你已经活了"</span> + ss / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span> + <span class="string">"天"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ul>
<li><p>（java.lang包）可以获取系统相关的信息或系统级操作，其中的方法都是静态的，可以通过类名直接使用</p>
</li>
<li><p>常用方法</p>
<ul>
<li><p>long System.currentTimeMillis();   返回以毫秒为单位的当前时间，可以用于测试程序的运行时间</p>
</li>
<li><p>void arraycopy（Object src, int srcPos, Object dest, int destPos, int length)     从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p>
<ul>
<li><p>src - 源数组。</p>
</li>
<li><p>srcPos - 源数组中的起始位置。</p>
</li>
<li><p>dest - 目标数组。</p>
</li>
<li><p>destPos - 目标数据中的起始位置。</p>
</li>
<li><p>length - 要复制的数组元素的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [1,2,3,4,5]  [6,7,8,9,10] ==&gt;  [1,2,3,4,5]  [1,2,3,9,10]</span></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a)+<span class="string">" "</span>+ Arrays.toString(b));</span><br><span class="line">        System.arraycopy(a,<span class="number">0</span>,b,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a)+<span class="string">" "</span>+ Arrays.toString(b));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="StringBulider"><a href="#StringBulider" class="headerlink" title="StringBulider"></a>StringBulider</h2><ul>
<li><p>String类   字符串是常量；它们的值在创建之后不能更改，字符串的底层时一个被final修饰的数组，不能改变，是一个常量</p>
</li>
<li><p>进行字符串的相加，内存在就会有多个字符串，占用空间多，效率低下。</p>
<ul>
<li>String  s = “a” + “b”  + “c”= “abc”  会产生五个字符串  a   b  c  ab  abc</li>
</ul>
</li>
<li><p>StringBulider 字符串缓冲区，可以提高操作效率（看成一个长度可变的字符串）</p>
</li>
<li><p>StringBulider  底层也是一个数组，但没有被final修饰，可以改变长度</p>
</li>
<li><p>StringBulider  在内存中始终是单个数组占用空间少，效率高，如果超出了StringBulider  的容量，会自动扩容</p>
</li>
<li><p>构造方法</p>
<ul>
<li>StringBulider  ()  构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。 </li>
<li>StringBuilder(String str)   构造一个字符串生成器，并初始化为指定的字符串内容。</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li><p>StringBulider append()   将任意类型的数据追加到序列,并返回this,调用方法的对象本身,使用append方法无需接受返回值</p>
<ul>
<li>链式编程 :方法返回值是一个对象,可以继续调用方法<ul>
<li>strBu.append(1).append(8.8).append(“abc”).append(“中”);</li>
</ul>
</li>
</ul>
</li>
<li><p>String toString()   实现StringBulider和String的相互转换</p>
<ul>
<li><p>String=&gt;StringBuilder    用构造方法就可以</p>
</li>
<li><p>StringBulider=&gt;String     用toString()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str  =<span class="string">"hello"</span>;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">    stringBuilder.append(<span class="string">"123"</span>).append(<span class="keyword">true</span>).append(<span class="string">"中华"</span>);</span><br><span class="line">    String str1 = stringBuilder.toString();</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>基本数据类型,使用起来非常方便,但是没有对应的方法来操作这些基本类型的数据,可以使用一个类,吧基本类型的数据装起来,在类中定义一些方法,这些类叫做包装类,我们可以使用类中的方法来操作这些基本类型的数据</p>
<ul>
<li><img src= "/img/loading.gif" data-src="/2020/07/13/1/%E5%8C%85%E8%A3%85%E7%B1%BB.png" alt="包装类"></li>
</ul>
</li>
<li><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">装箱:把基本类型的数据,包装到包装类中(基本数据类型-&gt;包装类)以Integer举例</span></span><br><span class="line"><span class="comment">构造方法:</span></span><br><span class="line"><span class="comment">    Integer(int value)  构造一个新分配的 Integer 对象，它表示指定的 int 值。</span></span><br><span class="line"><span class="comment">    Integer(String s)  构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。</span></span><br><span class="line"><span class="comment">    传递的字符串必须是基本类型的数据  "100"正确  "a"错误</span></span><br><span class="line"><span class="comment">静态方法:</span></span><br><span class="line"><span class="comment">    Integer(int value) 构造一个新分配的 Integer 对象，它表示指定的 int 值。</span></span><br><span class="line"><span class="comment">    Integer(String s) 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本数据类型)</span></span><br><span class="line"><span class="comment">成员方法:</span></span><br><span class="line"><span class="comment">    int intValue()   以 int 类型返回该 Integer 的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//装箱</span></span><br><span class="line">    Integer integer = <span class="keyword">new</span> Integer(<span class="string">"100"</span>);</span><br><span class="line">    Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">    Integer integer2 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    Integer integer3 = Integer.valueOf(<span class="string">"2"</span>);</span><br><span class="line">    System.out.println(integer);<span class="comment">//100</span></span><br><span class="line">    <span class="comment">//拆箱</span></span><br><span class="line">    <span class="keyword">int</span> a = integer.intValue();</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 自动装箱与拆箱:基本数据类型与包装类之间可以自动相互转换</span></span><br><span class="line"><span class="comment">* jdk1.5之后的新特性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自动装箱  直接把int类型的数据赋值给包装类</span></span><br><span class="line">        Integer integer = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//自动拆箱:integer是包装类,无法直接参与运算,可以自动转换为基本数据类型,再进行计算</span></span><br><span class="line">        <span class="comment">//相当于 integer = integer.intValue()+2;</span></span><br><span class="line">        integer = integer + <span class="number">2</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);<span class="comment">//这个方法本来需要存放integer类型的数据,但是此处自动装箱了</span></span><br><span class="line">        <span class="keyword">int</span> a = list.get(<span class="number">0</span>);<span class="comment">//本需要拆箱的,此处自动拆箱了</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="基本类型与字符串类型直接的相互转换"><a href="#基本类型与字符串类型直接的相互转换" class="headerlink" title="基本类型与字符串类型直接的相互转换"></a>基本类型与字符串类型直接的相互转换</h3><ul>
<li><p>基本类型变为字符串</p>
<ol>
<li>基本类型的值+””   (最简单的方法)</li>
<li>包装类的静态方法toString(参数),  不是Object的toString().<ul>
<li>static String toString(int i)     返回一个表示指定整数的 String 对象。 </li>
</ul>
</li>
<li>String类的静态方法valueOf(参数) <ul>
<li>static String valueOf(int i)      返回 int 参数的字符串表示形式 </li>
</ul>
</li>
</ol>
</li>
<li><p>字符串变为基本类型</p>
<ol>
<li>使用包装类的静态方法parseXXX(“数值类型的字符串”)<ul>
<li>Integer类 :   static  int  parseInt (String s)</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基本类型-&gt;字符串</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    String s1 = i + <span class="string">""</span>;</span><br><span class="line">    String s2 = Integer.toString(i);</span><br><span class="line">    String s3 = String.valueOf(i);</span><br><span class="line">    <span class="comment">//字符串-&gt;基本类型</span></span><br><span class="line">    <span class="keyword">int</span> j = Integer.parseInt(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><ul>
<li><p>集合数组区别</p>
<ul>
<li><p>数组的长度是固定的,集合的长度是可变的</p>
</li>
<li><p>数组中存储的是同一类型的元素,可以存储基本数据类型值.集合存储的都是对象.而且对象的类型可以不一致,在开发中一般当对象多的时候,使用集合进行存储.</p>
</li>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/13/1/%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84.png" alt="集合架构"></p>
</li>
<li><p>集合框架学习方式</p>
<ol>
<li><p>学习顶层:学习顶层接口/抽象类中共性的方法,所有的子类都可以使用</p>
</li>
<li><p>使用底层:顶层不是接口就是抽象类,无法创建对象使用,需使用底层的子类创建对象使用</p>
</li>
</ol>
</li>
<li><h3 id="collection常用功能"><a href="#collection常用功能" class="headerlink" title="collection常用功能"></a>collection常用功能</h3><ul>
<li><p>boolean add(E e);  把给定的对象添加到当前集合中</p>
</li>
<li><p>void clear();   清空集合中所有元素</p>
</li>
<li><p>boolean remove(E e);   把给定的对象在当前集合中删除</p>
</li>
<li><p>boolean contains(E e);   判断当前集合中是否包含给定的对象</p>
</li>
<li><p>boolean isEmpty();   判断当前集合是否为空</p>
</li>
<li><p>int size();   返回集合中元素的个数</p>
</li>
<li><p>Object[ ]  toArray();    把集合中的元素,  存储到数组中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建集合对象,可以使用多态</span></span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    System.out.println(coll);  <span class="comment">//collection重写了toString() []</span></span><br><span class="line">    <span class="comment">//boolean add(E e); 一般返回都是true,所以可以不一接受,添加元素</span></span><br><span class="line">    coll.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">    coll.add(<span class="string">"杨幂"</span>);</span><br><span class="line">    coll.add(<span class="string">"张三"</span>);</span><br><span class="line">    System.out.println(coll);<span class="comment">//输出所有内容</span></span><br><span class="line">    <span class="comment">//boolean remove(E e);  返回值是布尔值,若元素存在,删除元素,返回true</span></span><br><span class="line">    coll.remove(<span class="string">"张三"</span>);</span><br><span class="line">    System.out.println(coll);</span><br><span class="line">    <span class="comment">//boolean contains(E e);</span></span><br><span class="line">    <span class="keyword">boolean</span> bool = coll.contains(<span class="string">"李四"</span>);<span class="comment">//返回false</span></span><br><span class="line">    <span class="comment">//boolean isEmpty();</span></span><br><span class="line">    <span class="keyword">boolean</span> bool2 = coll.isEmpty();<span class="comment">//为空返回true 不为空返回false</span></span><br><span class="line">    <span class="comment">//int size();</span></span><br><span class="line">    <span class="keyword">int</span> size = coll.size();<span class="comment">//返回集合长度</span></span><br><span class="line">    <span class="comment">//Object[] toArray();   把集合中的元素,存储到数组中</span></span><br><span class="line">    Object[] array = coll.toArray();<span class="comment">//返回一个集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;<span class="comment">//遍历集合</span></span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//void clear();   清空集合中所有元素,但是不删除集合</span></span><br><span class="line">    coll.clear();<span class="comment">//集合此时为 []</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="Iterator-lt-gt-接口-迭代器-通用的取出元素的方式"><a href="#Iterator-lt-gt-接口-迭代器-通用的取出元素的方式" class="headerlink" title="Iterator&lt;&gt;接口 (迭代器) :  通用的取出元素的方式"></a>Iterator&lt;&gt;接口 (迭代器) :  通用的取出元素的方式</h3><ul>
<li><p>方法</p>
<ul>
<li>boolean hasNext() 如果仍有元素可以迭代，则返回 true。 </li>
<li>E next() 返回迭代的下一个元素。 </li>
<li>void remove()   从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  boolean hasNext() 如果仍有元素可以迭代，则返回 true。</span></span><br><span class="line"><span class="comment">        E next() 取出集合的下一个元素。</span></span><br><span class="line"><span class="comment">        Iterator是一个接口,我们无法使用,需要使用Iterator接口的实现类对象,获取实现类的方法比较特殊</span></span><br><span class="line"><span class="comment">        Collection中有一个方法,叫iterator(),这个方返回的就是迭代器的实现类对象</span></span><br><span class="line"><span class="comment">        迭代器使用步骤(重点)</span></span><br><span class="line"><span class="comment">            1.使用计划中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收()多态</span></span><br><span class="line"><span class="comment">            2.使用Iterator接口中的hasNext()判断还有没有下一个元素</span></span><br><span class="line"><span class="comment">            3.使用Iterator接口中的方法next取出集合中的下一个元素</span></span><br><span class="line"><span class="comment">        Iterator也是有泛型的,集合是什么泛型,迭代器就是什么泛型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        coll.add(<span class="string">"杨幂"</span>);</span><br><span class="line">        coll.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        coll.add(<span class="string">"刘亦菲"</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">        <span class="comment">//多态     接口          实现类对象</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;<span class="comment">//判断集合中是否有元素</span></span><br><span class="line">            String str = it.next();<span class="comment">//取出每个元素</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用for循环不推荐</span></span><br><span class="line"><span class="comment">//        for (Iterator&lt;String&gt; it2 = coll.iterator();it2.hasNext();)&#123;</span></span><br><span class="line"><span class="comment">//            String str = it.next();//取出每个元素</span></span><br><span class="line"><span class="comment">//            System.out.println(str);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">       String str1 = it.next();<span class="comment">//此时已没有元素了,抛 NosuchElementException 异常</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="增强for循环-foreach-专门用来遍历集合跟数组"><a href="#增强for循环-foreach-专门用来遍历集合跟数组" class="headerlink" title="增强for循环(foreach):专门用来遍历集合跟数组"></a>增强for循环(foreach):专门用来遍历集合跟数组</h3><ul>
<li><p>底层使用的也是迭代器,使用for循环的格式,简化了迭代器的书写,是jdk1.5之后的新特性</p>
</li>
<li><p>接口 Collection<E> extends Iterable<E>   所有的单列集合都可以使用”foreach”</E></E></p>
</li>
<li><p>格式 : <code>for(集合/数组的数据类型 变量名: 集合名/数组名){  sout(变量名)  }</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">    list.add(<span class="string">"杨幂"</span>);</span><br><span class="line">    list.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123; <span class="comment">//对集合遍历</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array)&#123;<span class="comment">//对数组遍历</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>泛型可以看做一种未知的数据类型,当不知道使用什么数据类型的时候,可以使用泛型</p>
<ul>
<li>E e :Element 元素</li>
<li>T t : Type 类型</li>
</ul>
</li>
<li><p>ArrayList 定义的时候不确定使用什么类型,所以使用了泛型 </p>
</li>
<li><p>创建集合对象的时候,就会确定泛型的数据类型</p>
<ul>
<li>ArrayList<String> list = new ArrayList&lt;&gt;();</String></li>
</ul>
</li>
<li><p>创建集合对象不使用泛型</p>
<ul>
<li><p>好处: 集合不使用泛型,默认的类型就是Object类型,可以存储任意类型的数据</p>
</li>
<li><p>弊端: 不安全,会引发类型装换异常异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//存放的是Object类型数据</span></span><br><span class="line">     list.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">     list.add(<span class="number">1</span>);</span><br><span class="line">     Iterator iterator = list.iterator();</span><br><span class="line">     iterator.hasNext();</span><br><span class="line">     Object object = iterator.next();<span class="comment">//获取赵丽颖</span></span><br><span class="line">     String str = (String) object;</span><br><span class="line">     System.out.println(str);<span class="comment">//字符串转字符串正常</span></span><br><span class="line">     Object object1 =iterator.next();<span class="comment">//获取1</span></span><br><span class="line">     String str1 = (String) object1;<span class="comment">//int类型转字符串,会有ClassCastException类型转换异常</span></span><br><span class="line">     System.out.println(str1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="创建集合对象使用泛型"><a href="#创建集合对象使用泛型" class="headerlink" title="创建集合对象使用泛型"></a>创建集合对象使用泛型</h3><ul>
<li><p>好处: 避免了类型转换的麻烦,存储什么类型,取出就是什么类型,   把运行期异常提升到了编译期</p>
</li>
<li><p>弊端: 泛型是什么类型,只能存储什么类型的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);<span class="comment">//存储非字符串类型,报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="自定义含有泛型的类"><a href="#自定义含有泛型的类" class="headerlink" title="自定义含有泛型的类"></a>自定义含有泛型的类</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的参数设置为泛型,可以传入任意泛型的参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  E name ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不写泛型默认为Object类型</span></span><br><span class="line">        GenericClass genericClass = <span class="keyword">new</span> GenericClass();</span><br><span class="line">        genericClass.setName(<span class="string">"此处为Object类型"</span>);</span><br><span class="line">        <span class="comment">//创建GenericClass对象,泛型为Integer</span></span><br><span class="line">        GenericClass&lt;Integer&gt; gc= <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">        gc.setName(<span class="string">"赵丽颖"</span>);<span class="comment">//类型错误,会报错</span></span><br><span class="line">        gc.setName(<span class="number">111</span>);<span class="comment">//类型正确</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带有泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//泛型的普通方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(M m)</span> </span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">(S m)</span> </span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">          GenericMethod genericMethod = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">          <span class="comment">//使用泛型方法</span></span><br><span class="line">          genericMethod.method(<span class="number">10</span>);<span class="comment">//可以传入任意类型,会自动装箱</span></span><br><span class="line">          genericMethod.method(<span class="string">"赵丽颖"</span>);</span><br><span class="line">          genericMethod.method(<span class="keyword">true</span>);</span><br><span class="line">          <span class="comment">//调用泛型静态方法</span></span><br><span class="line">          GenericMethod.method1(<span class="number">321</span>);<span class="comment">//类名.方法名调用</span></span><br><span class="line">       	GenericMethod.method1(<span class="string">"杨幂"</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种实现类指定泛型类型</span></span><br><span class="line"><span class="comment">//1.含有泛型接口的实现类,需指定接口的泛型</span></span><br><span class="line"><span class="comment">//Scanner类实现了Iterator接口,并指定接口的泛型为String,所以重新的next方法泛型默认就是String</span></span><br><span class="line"><span class="comment">//public final class Scanner implements Iterator&lt;String&gt;&#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种实例化是指定泛型类型</span></span><br><span class="line"><span class="comment">//2.含有泛型接口的第二种使用方式:接口使用什么泛型,实现类就使用什么泛型,类跟着接口走</span></span><br><span class="line"><span class="comment">//    就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl1</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试含有泛型接口的实现类</span></span><br><span class="line"><span class="comment">//第一种实现类指定泛型类型,第二种实例化是指定泛型类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一张泛型实现调用</span></span><br><span class="line">    GenericInterfaceImpl genericInterface = <span class="keyword">new</span> GenericInterfaceImpl();</span><br><span class="line">    genericInterface.method(<span class="string">"实现类指定的是字符串只能是字符串"</span>);</span><br><span class="line">    <span class="comment">//第二种泛型实现调用,需手动指定泛型</span></span><br><span class="line">    GenericInterfaceImpl1&lt;Integer&gt; genericInterfaceImpl1 = <span class="keyword">new</span> GenericInterfaceImpl1();</span><br><span class="line">    genericInterfaceImpl1.method(<span class="number">123</span>);<span class="comment">//调用时指定的是Inerger只能是Integer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="泛型的通配符-lt-gt-泛型不确定是可以使用通配符-但是一旦使用泛型的通配符后-只能使用Object类中的共性方法-集合中元素自身方法无法使用"><a href="#泛型的通配符-lt-gt-泛型不确定是可以使用通配符-但是一旦使用泛型的通配符后-只能使用Object类中的共性方法-集合中元素自身方法无法使用" class="headerlink" title="泛型的通配符 &lt;?&gt; : 泛型不确定是可以使用通配符   ,但是一旦使用泛型的通配符后,只能使用Object类中的共性方法,集合中元素自身方法无法使用"></a>泛型的通配符 &lt;?&gt; : 泛型不确定是可以使用通配符   ,但是一旦使用泛型的通配符后,只能使用Object类中的共性方法,集合中元素自身方法无法使用</h3><ul>
<li><p>不知道用什么类型来接受的时候,此时可以使用?,?表示未知通配符,此时只能接受数据,不能存储数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 泛型的通配符:</span></span><br><span class="line"><span class="comment"> *   ? 代表任意的数据类型</span></span><br><span class="line"><span class="comment"> * 使用方式:</span></span><br><span class="line"><span class="comment"> *   不能创建对象使用</span></span><br><span class="line"><span class="comment"> *   只能作为方法的参数使用</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> *   定义时不能使用&lt;?&gt; ArrayList&lt;?&gt; list = new ArrayList&lt;&gt;();为错误写法</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(<span class="number">1</span>);</span><br><span class="line">        list01.add(<span class="number">2</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list02.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        list02.add(<span class="string">"杨幂"</span>);</span><br><span class="line">        <span class="comment">//调用自定义方法,此时可以打印任意类集合数据</span></span><br><span class="line">        printArray(list01);</span><br><span class="line">        printArray(list02);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个遍历ArrayList方法,此时不知道遍历的数据类型是什么,可以使用泛型通配符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//Objiet类型可以接收任意类型数据</span></span><br><span class="line">            Object obj = it.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通配符高级使用–受限泛型</p>
<ul>
<li><p>泛型的上限</p>
<ul>
<li>格式:   类型名称&lt;? extends  类&gt; 对象名称</li>
<li>意义:   只接收该类型的及其子类</li>
</ul>
</li>
<li><p>泛型的下限</p>
<ul>
<li>格式:   类型名称&lt;? super 类&gt;  对象名称</li>
<li>意义:   只能接收该类型及其父类型</li>
</ul>
</li>
<li><p>比如 现已知Object类, String类, Number类, Integer类,  其中Number类是Intege的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Integer extends  Number  extends Object</span></span><br><span class="line">        <span class="comment">//String  extends Object</span></span><br><span class="line">        Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">        Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        getElement1(list1);</span><br><span class="line">        getElement1(list2); <span class="comment">//报错</span></span><br><span class="line">        getElement1(list3);</span><br><span class="line">        getElement1(list4); <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">        getElement2(list1); <span class="comment">//报错</span></span><br><span class="line">        getElement2(list2); <span class="comment">//报错</span></span><br><span class="line">        getElement2(list3);</span><br><span class="line">        getElement2(list4);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型的上限:此时的泛型?,必须是Number类型,或者是Number的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型的下限:此时的泛型?,必须是Number类型,或者是Number的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="collection综合案例-斗地主"><a href="#collection综合案例-斗地主" class="headerlink" title="collection综合案例(斗地主)"></a>collection综合案例(斗地主)</h3><ul>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/13/1/%E6%96%97%E5%9C%B0%E4%B8%BB%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="斗地主案例分析"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDiZhu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.准备牌</span></span><br><span class="line">        <span class="comment">//定义一个存储54张牌的集合,泛型使用字符串</span></span><br><span class="line">        ArrayList&lt;String&gt; poker = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义两个数组,一个存序号,一存花色</span></span><br><span class="line">        String[] colors = &#123;<span class="string">"♠"</span>, <span class="string">"♥"</span>, <span class="string">"♣"</span>, <span class="string">"♦"</span>&#125;;</span><br><span class="line">        String[] numbers = &#123;<span class="string">"2"</span>, <span class="string">"A"</span>, <span class="string">"K"</span>, <span class="string">"Q"</span>, <span class="string">"J"</span>, <span class="string">"10"</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"7"</span>, <span class="string">"6"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>, <span class="string">"3"</span>,&#125;;</span><br><span class="line">        <span class="comment">//先存大小王</span></span><br><span class="line">        poker.add(<span class="string">"大王"</span>);</span><br><span class="line">        poker.add(<span class="string">"小王"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                <span class="comment">//将组装好的牌放到集合中</span></span><br><span class="line">                poker.add(color + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.洗牌,使用Collections中静态方法</span></span><br><span class="line">        Collections.shuffle(poker);</span><br><span class="line">        System.out.println(poker);</span><br><span class="line">        <span class="comment">//3.发牌</span></span><br><span class="line">        <span class="comment">//定义四个集合存储玩家牌和底牌</span></span><br><span class="line">        ArrayList&lt;String&gt; play01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; play02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; play03 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; diPai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历poker集合获取每一张牌</span></span><br><span class="line">        <span class="comment">//使用poker集合的索引,给玩家轮流发牌,剩余三张给底牌,i&gt;51 就发完了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poker.size(); i++) &#123;</span><br><span class="line">            String p = poker.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                diPai.add(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//给玩家1发牌</span></span><br><span class="line">                play01.add(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//给玩家2发牌</span></span><br><span class="line">                play02.add(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//给玩家3发牌</span></span><br><span class="line">                play03.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.看牌</span></span><br><span class="line">        System.out.println(<span class="string">"刘德华:"</span> + play01);</span><br><span class="line">        System.out.println(<span class="string">"周润发:"</span> + play02);</span><br><span class="line">        System.out.println(<span class="string">"周星驰:"</span> + play03);</span><br><span class="line">        System.out.println(<span class="string">"底牌:"</span> + diPai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">刘德华:[♦<span class="number">7</span>, ♦J, 小王, ♦A, ♣<span class="number">4</span>, ♠<span class="number">9</span>, ♦<span class="number">8</span>, ♠<span class="number">6</span>, ♣<span class="number">10</span>, ♠<span class="number">4</span>, ♣<span class="number">7</span>, ♥K, ♥<span class="number">5</span>, ♦<span class="number">9</span>, ♥<span class="number">10</span>, ♠<span class="number">7</span>, ♥<span class="number">9</span>]</span><br><span class="line">周润发:[♠J, ♠<span class="number">10</span>, ♥<span class="number">8</span>, ♦<span class="number">5</span>, ♣<span class="number">3</span>, ♣<span class="number">8</span>, ♠<span class="number">5</span>, ♥<span class="number">3</span>, ♠<span class="number">3</span>, ♠<span class="number">8</span>, ♦K, ♦Q, ♣Q, ♦<span class="number">3</span>, 大王, ♥Q, ♥J]</span><br><span class="line">周星驰:[♣<span class="number">6</span>, ♥<span class="number">4</span>, ♠A, ♥<span class="number">6</span>, ♣K, ♣<span class="number">9</span>, ♠<span class="number">2</span>, ♣A, ♠K, ♣<span class="number">5</span>, ♦<span class="number">6</span>, ♥<span class="number">7</span>, ♣<span class="number">2</span>, ♥<span class="number">2</span>, ♣J, ♥A, ♦<span class="number">2</span>]</span><br><span class="line">底牌:[♠Q, ♦<span class="number">10</span>, ♦<span class="number">4</span>]</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="List集合接口-extends-Collection"><a href="#List集合接口-extends-Collection" class="headerlink" title="List集合接口 extends Collection"></a>List集合接口 extends Collection</h3><ul>
<li><p>特点</p>
<ul>
<li>是一个有序的集合,存取元素和取出元素的顺序是一致的</li>
<li>有索引,包含了一些带索引的方法</li>
<li>运行存储重复元素</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>E get (int index)  返回集合中指定位置元素</li>
<li>E remove(int index)  删除集合中指定位置元素</li>
<li>E set (int index, E e)  用指定元素替换集合中指定位置元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用索引时应注意索引越界异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        list.add(<span class="string">"周润发"</span>);</span><br><span class="line">        list.add(<span class="string">"刘德华"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//在1号位置添加迪丽热巴</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        <span class="comment">//移除2号位置元素,并返回移除元素</span></span><br><span class="line">        String removeE = list.remove(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//替换0位置元素,并返回被替换元素</span></span><br><span class="line">        String setE = list.set(<span class="number">0</span>,<span class="string">"杨幂"</span>);</span><br><span class="line">        <span class="comment">//list集合遍历有三种方式</span></span><br><span class="line">        <span class="comment">//1.普通for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            String string = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.增强for循环</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>List集合的实现类</p>
<ul>
<li><p><strong>ArrayList</strong>集合:  底层是一个数组结构,增删时,会创建一个新的数组,影响效率需谨慎使用,异步的</p>
</li>
<li><p><strong>LinkedList</strong>集合:  底层是一个链表结构, 查询时,会从头查找,影响效率,异步的</p>
<ul>
<li><p>有大量的关于首尾元素的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * LinkedList implements List接口</span></span><br><span class="line"><span class="comment">         * 底层是一个链表结构,查询慢,增删快,使用特有方法不能使用多态</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        LinkedList&lt;String&gt; linked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        linked.add(<span class="string">"a"</span>);</span><br><span class="line">        linked.add(<span class="string">"b"</span>);</span><br><span class="line">        linked.add(<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">//void addFirst(E e)将指定元素插入开头</span></span><br><span class="line">        linked.addFirst(<span class="string">"www"</span>);</span><br><span class="line">        <span class="comment">//void push(E e) 等效于addFirst</span></span><br><span class="line">        linked.push(<span class="string">"http"</span>);</span><br><span class="line">        <span class="comment">//void addLast(E e)将指定元素插入结尾</span></span><br><span class="line">        linked.addLast(<span class="string">"com"</span>);</span><br><span class="line">        <span class="comment">//E getFirst()  返回第一个元素</span></span><br><span class="line">        String str = linked.getFirst();</span><br><span class="line">        <span class="comment">//E getLast()  返回最后一个元素</span></span><br><span class="line">        String str1 = linked.getLast();</span><br><span class="line">        <span class="comment">//boolean isEmpty()  若空返回true</span></span><br><span class="line">        <span class="keyword">boolean</span> b = linked.isEmpty();</span><br><span class="line">        <span class="comment">//E removeFirst() 删除并返回此列表的第一个</span></span><br><span class="line">        String removeStr  = linked.removeFirst();</span><br><span class="line">        <span class="comment">//E removeLast() 移除并返回此列表的最后一个</span></span><br><span class="line">        String removestr1 = linked.removeLast();</span><br><span class="line">        <span class="comment">//E pop()   效果同removeLast一样</span></span><br><span class="line">        String removeStr2 = linked.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Vector</strong> 集合(JDK1.1版本最早期的集合,了解)</p>
<ul>
<li>可以实现可增长的对象数组</li>
<li>同步的,已被ArrayList取代   </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Set集合接口-extends-Collection"><a href="#Set集合接口-extends-Collection" class="headerlink" title="Set集合接口 extends Collection"></a>Set集合接口 extends Collection</h3><ul>
<li><p>特点</p>
<ul>
<li>不允许存储重复元素</li>
<li>没有索引,没有带索引的方法,也不能使用普通的for循环遍历,</li>
</ul>
</li>
<li><h4 id="HashSet-实现类"><a href="#HashSet-实现类" class="headerlink" title="HashSet 实现类"></a>HashSet 实现类</h4><ul>
<li><p>不允许存储重复元素</p>
</li>
<li><p>HashSet implements Set</p>
</li>
<li><p>存储和取出元素的顺可能不一致</p>
</li>
<li><p>底层是一个哈希表结构(查询速度非常的快)</p>
</li>
<li><p>哈希值:是一个十进制的整数,由系统随机给出(就是对象地址,是一个逻辑地址,不是数据实际存储的物理地址,在Object的<code>int hashCode()</code>方法可以获取对象的哈希值)</p>
<ul>
<li><p>方法源码: public native int hashCode();</p>
</li>
<li><p>native : 代表该方法调用的时本地操作系统方法</p>
</li>
<li><p>可以直接使用<code>System.out.println(对象名.hashCode());</code>输出对象的哈希值</p>
</li>
<li><p>` public String toString() {</p>
<pre><code>return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</code></pre><p>  }`   Object的toString()方法  返回的其实就是一个哈希值</p>
</li>
<li><p>String 类的哈希值</p>
<ul>
<li><p>String 重写了Object 的hashCode()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String  s1 = <span class="keyword">new</span> String (<span class="string">"abc"</span>);</span><br><span class="line">String  s2 = <span class="keyword">new</span> String (<span class="string">"abc"</span>);</span><br><span class="line">s1.hashCode();</span><br><span class="line">s2.hashCode();<span class="comment">//这两个哈希值一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>哈希表</strong></p>
<ul>
<li>特点:  速度快</li>
<li>1.7之前  <strong>哈希表 = 数组+链表</strong></li>
<li>1.8之后  <strong>哈希表 = 数组+链表 ,  哈希表 = 数组+红黑树</strong>(提高查询速度)</li>
<li>初始容量16个</li>
<li><img src= "/img/loading.gif" data-src="/2020/07/13/1/%E5%93%88%E5%B8%8C%E5%80%BC.png" alt="哈希值"></li>
</ul>
</li>
</ul>
</li>
<li><p>Set集合不允许存储重复元素的原理</p>
<ul>
<li>Set集合在调用add方法时,add方法会调用元素的hashCode方法和equals方法,判断元素是否重复</li>
<li><img src= "/img/loading.gif" data-src="/2020/07/13/1/set%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8E%9F%E7%90%86.png" alt="set不重复原理"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用: 要想元素不重复, 需重写类的 equals()和hashCode() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set保存元素唯一只能是其中一种&#123; Integer, String , Person...&#125;</span></span><br><span class="line"><span class="comment"> * 要求:</span></span><br><span class="line"><span class="comment"> *   同名和同龄的人,视为同一个人,只能存储一次</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//getter  setter暂时省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="comment">//重写toString,直接打印对象时,输出不再是地址值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//重写equals,比较各个元素是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="comment">//重写hashCode返回哈希值</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main中使用:</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建HashSet集合存储person</span></span><br><span class="line">        HashSet&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"赵丽颖"</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"赵丽颖"</span>,<span class="number">19</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"赵丽颖"</span>,<span class="number">18</span>);</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);<span class="comment">//不会添加,重写了hashCode和equals</span></span><br><span class="line">        System.out.println(set);<span class="comment">//不会有重复元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="LinkedHashset集合-extends-HashSet"><a href="#LinkedHashset集合-extends-HashSet" class="headerlink" title="LinkedHashset集合  extends HashSet"></a>LinkedHashset集合  extends HashSet</h4><ul>
<li><p>具有可预知迭代顺序的 Set 接口的哈希表和链接列表的实现,与HashSet不同之处在于,LinkedHashSet维护这一个运行于所有条目的双重链接列表.</p>
</li>
<li><p>底层是一个<strong>Hash表(数组+链表/红黑树)+链表</strong>, 多了一条链表用来记录元素的存储顺序,保证元素有序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//HashSet无序,LinkedHashSet有序</span></span><br><span class="line">    <span class="comment">//均不允许重复</span></span><br><span class="line">    LinkedHashSet&lt;String&gt; linked = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    linked.add(<span class="string">"www"</span>);</span><br><span class="line">    linked.add(<span class="string">"baidu"</span>);</span><br><span class="line">    linked.add(<span class="string">"com"</span>);<span class="comment">//此处顺序不会改变</span></span><br><span class="line">    System.out.println(linked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li><p>JDK1.5之后出现的新特性</p>
</li>
<li><p>使用前提:  当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数</p>
</li>
<li><p>使用格式: 定义方法时使用,  <code>修饰符 返回值类型 方法名(数据类型... 变量名){}</code></p>
</li>
<li><p>原理:  底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数,传递的参数可以是 0个(不传递),1,2,3,…多个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">       System.out.println(demo04(a));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//使用可变参数 int... arr</span></span><br><span class="line"><span class="comment">/*注意:</span></span><br><span class="line"><span class="comment">	一个方法的参数列表,只能有一个可变参数</span></span><br><span class="line"><span class="comment">		错误写法: method(int... a, String... str)  只能有一个可变参数</span></span><br><span class="line"><span class="comment">	如果方法的参数由多个,那么可变参数必须写在参数列表的末尾</span></span><br><span class="line"><span class="comment">		如 :  method(int i, String str, int... arr)</span></span><br><span class="line"><span class="comment">	可变参数的特殊写法(终极写法)</span></span><br><span class="line"><span class="comment">		Object... obj</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">demo04</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 定义一个个方法计算0个到n个int整数的和</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">       System.out.println(arr);<span class="comment">//打印数组的地址</span></span><br><span class="line">       System.out.println(arr.length);<span class="comment">//参数的长度由传入指定</span></span><br><span class="line">       <span class="keyword">int</span> sum  = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123; <span class="comment">//遍历arr求和</span></span><br><span class="line">           sum+=i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="Collections集合"><a href="#Collections集合" class="headerlink" title="Collections集合"></a>Collections集合</h2><ul>
<li><p>是一个集合工具类,用来的对集合进行操作</p>
</li>
<li><p>部分方法:</p>
<ul>
<li><p>static <T> bollean addAll(Collection<T> c, T… element):往集合中添加一些元素</T></T></p>
</li>
<li><p>static void shuffle(List&lt;?&gt; list):  打乱集合顺序</p>
</li>
<li><p>static <T> void sort(List<T> list)  将集合中元素按照默认规则排序</T></T></p>
<ul>
<li>使用前提: 被排序的元素,必须实现Comparable,重写接口中的方法compareTo()定义排序规则</li>
<li>Comparable排序规则:    .<ul>
<li>自己(this)-参数  升序   </li>
<li>参数-自己(this)  降序</li>
</ul>
</li>
</ul>
</li>
<li><p>static <T> void sort(List<T> list, Comparator&lt;?  super  T&gt;)  将集合中元素按照指定规则排序</T></T></p>
<ul>
<li>Compara<font color="red">ble</font> 与 Compara<font color="red">tor</font>区别<ul>
<li>Comparabel : 自己(this) 和别人(参数)比较,自己需要实现Compareable接口,重写比较规则的compareTo方法</li>
<li>Comparator :  相当于给个第三方的裁判,比较两个元素</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对谁排序接口Comparable&lt;&gt;泛型写谁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//getter  setter暂时省略</span></span><br><span class="line">    <span class="comment">//主要学习排序,其他省略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写Comparable的排序规则</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*return 0;//默认返回0,认为元素都是相同的</span></span><br><span class="line"><span class="comment">        自定义排序规则,比较两个人的年龄(this,参数 Person)</span></span><br><span class="line"><span class="comment">        Comparable排序规则:</span></span><br><span class="line"><span class="comment">            自己(this)-参数  升序</span></span><br><span class="line"><span class="comment">            参数-自己(this)  降序</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge()-person.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主方法使用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>);<span class="comment">//静态方法,,添加多个元素</span></span><br><span class="line">    Collections.shuffle(list);<span class="comment">//静态方法,打乱集合顺序</span></span><br><span class="line">    Collections.sort(list); <span class="comment">//静态方法,对集合默认排序</span></span><br><span class="line">    <span class="comment">//对自定义类型排序</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"赵丽颖"</span>,<span class="number">18</span>);</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person(<span class="string">"杨幂"</span>,<span class="number">20</span>);</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person(<span class="string">"a杨颖"</span>,<span class="number">19</span>);</span><br><span class="line">    Person person3 = <span class="keyword">new</span> Person(<span class="string">"b杨颖"</span>,<span class="number">19</span>);</span><br><span class="line">    ArrayList&lt;Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(people,person,person1,person2,person3);</span><br><span class="line">    Collections.sort(people);<span class="comment">//若没实现compareTo方法,会报错</span></span><br><span class="line">    System.out.println(people);<span class="comment">//按年龄排好序的结果</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    扩展:了解</span></span><br><span class="line"><span class="comment">    Comparator中compare方法需重写自定义比较规则,此处用匿名类的方式重写</span></span><br><span class="line"><span class="comment">    参数:传一个集合,传一个比较器</span></span><br><span class="line"><span class="comment">    排序规则:</span></span><br><span class="line"><span class="comment">        o1-o2 升序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Collections.sort(people, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//按照年龄升序排序</span></span><br><span class="line">            <span class="keyword">int</span> result = o1.getAge()-o2.getAge();</span><br><span class="line">            <span class="comment">//如果两人年龄相同,则按照姓名第一个字母排序</span></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//按首字母升序</span></span><br><span class="line">                <span class="keyword">return</span> o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//年龄不同按年龄排序</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(people);<span class="comment">//年龄不同,按年龄排序,年龄相同,</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p><strong>K-V键值对, 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 双列集合,Collection是单列集合</strong></p>
<ul>
<li>特点<ul>
<li>是一个双列集合,一个元素包含两个值(一个KEY,一个VALUE)</li>
<li>Map集合中元素,key和value可以相同,也可以不同</li>
<li>Map集合中的元素,key是不允许重复的,value是运行重复的</li>
<li>Map集合中的元素,key和value是一一对应的</li>
</ul>
</li>
<li><img src= "/img/loading.gif" data-src="/2020/07/13/1/map%E9%9B%86%E5%90%88.png" alt="map集合"></li>
</ul>
<h3 id="常用的实现类"><a href="#常用的实现类" class="headerlink" title="常用的实现类"></a>常用的实现类</h3><ul>
<li><p>HashMap&lt;k,v&gt;  implements Map&lt;k,v&gt;接口</p>
<ul>
<li>特点:<ol>
<li>底层是哈希表,查询速度特变快<ul>
<li>JDK1.8之前 数组+单向链表</li>
<li>JDK1.8之后  数组+单向链表/红黑树(链表长度超过8):题告查询速度</li>
</ul>
</li>
<li>HashMap集合是一个无序的集合,存储元素和取出元素可能不一样</li>
<li>多线程,不安全,速度快,不同步</li>
</ol>
</li>
<li>LinkedHashMap&lt;k,v&gt; 集合  extends  HashMap&lt;k,v&gt; 集合<ul>
<li>特点</li>
<li>LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序)</li>
<li>LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的</li>
</ul>
</li>
</ul>
</li>
<li><p>Map集合中常见的方法</p>
<ul>
<li><p>boolean containsKey(Object key)   如果此映射包含指定键的映射关系，则返回 true。 </p>
</li>
<li><p>V put(K key, V value)    将指定的值与此映射中的指定键关联（可选操作).若key不存在,返回null,若key存在,替换value,返回旧value</p>
</li>
<li><p>V get(Object key)     返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回null</p>
</li>
<li><p>V remove(Object key)   如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 </p>
</li>
<li><p>Set<K> keySet()    返回此映射中包含的键的 Set 视图。 把Map中所有的key取出来放到Set集合中</K></p>
<ul>
<li><img src= "/img/loading.gif" data-src="/2020/07/13/1/Map%E4%B8%ADkeySet%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88.png" alt="Map中keySet遍历集合"></li>
</ul>
</li>
<li><p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()    返回此映射中包含的映射关系的 Set 视图。 </p>
<ul>
<li>Entry Map的内部接口,映射项（键-值对）。</li>
<li><img src= "/img/loading.gif" data-src="/2020/07/13/1/Map%E4%B8%AD%E7%9A%84Entry.png" alt="Map中的Entry"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试Map中的方法    </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// V put(K key, V value)  key不重复返回v是null,如存在,替换value 返回旧value</span></span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span>  HashMap&lt;&gt;();</span><br><span class="line">    String v1 = map.put(<span class="string">"李晨"</span>,<span class="string">"范冰冰"</span>);<span class="comment">//返回v1为null</span></span><br><span class="line">    System.out.println(v1);</span><br><span class="line">    String v2 = map.put(<span class="string">"李晨"</span>,<span class="string">"赵丽颖"</span>);<span class="comment">//返回v2为范冰冰</span></span><br><span class="line">    System.out.println(v2);</span><br><span class="line">    map.put(<span class="string">"冷锋"</span>,<span class="string">"龙小云"</span>);<span class="comment">//一般情况不需要接收返回值</span></span><br><span class="line">    map.put(<span class="string">"杨过"</span>,<span class="string">"小龙女"</span>);</span><br><span class="line">    <span class="comment">//V remove(Object key) key存在返回被删除的value,不存在返回null</span></span><br><span class="line">    String v3  = map.remove(<span class="string">"冷锋"</span>);<span class="comment">//删除"冷锋"返回v3为龙小云</span></span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="comment">//V get(Object key)   key存在返回对应的value,不存在返回null</span></span><br><span class="line">    String v4 = map.get(<span class="string">"杨过过"</span>);<span class="comment">//不存在返回null</span></span><br><span class="line">    <span class="comment">//boolean containsKey(Object key)   如果此映射包含指定键的映射关系，则返回 true。</span></span><br><span class="line">    <span class="keyword">boolean</span> bool = map.containsKey(<span class="string">"赵丽颖"</span>);<span class="comment">//key不存在返回false</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一种方式遍历元素:使用keySet()方法,通过键找值的方式</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用Map集合中的方法keySet()所有的键取出来放到Set集合中</span></span><br><span class="line"><span class="comment">        2.遍历Set集合,获取Map()集合中的每一个key</span></span><br><span class="line"><span class="comment">        3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Set&lt;String&gt; set = map.keySet();</span><br><span class="line">    <span class="comment">//使用迭代器</span></span><br><span class="line">    Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        String key = it.next();</span><br><span class="line">        String value = map.get(key);</span><br><span class="line">        System.out.println(<span class="string">"key:"</span>+key+<span class="string">"value:"</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用增强for</span></span><br><span class="line">    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        String value = map.get(key);</span><br><span class="line">        System.out.println(<span class="string">"key:"</span>+key+<span class="string">"value:"</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第二种方式遍历元素:使用entrySet()方法</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用Map集合中的方法entrySet()所有的entry对象取出来放到Set集合中</span></span><br><span class="line"><span class="comment">        2.遍历Set集合,获取集合中的每一个entry对象</span></span><br><span class="line"><span class="comment">        3.通过entry中的的方法getKey()获取key,getValue()获取值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; set1 = map.entrySet();</span><br><span class="line">    <span class="comment">//使用迭代器遍历</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it1 = set1.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it1.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; entry = it1.next();</span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        System.out.println(<span class="string">"key:"</span>+key+<span class="string">"value:"</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用增强for循环</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : set1) &#123;</span><br><span class="line">        String key1 = entry.getKey();</span><br><span class="line">        String value1 = entry.getValue();</span><br><span class="line">        System.out.println(<span class="string">"key:"</span> + key1 + <span class="string">"value:"</span> + value1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HashMap存储自定义类型得键值</p>
<ul>
<li><p>Map集合保证key是唯一的</p>
<ul>
<li>作为key的元素,必须重写hashCode()方法和equals()方法,保证key唯一</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Person类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//Getter Setter方法不是重点,暂时省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//Map中需要用到equals()和hashCode()方法比较key是否相同	</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main中使用</span><br><span class="line"><span class="comment">//自定义类型作为value可以重复</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>));</span><br><span class="line">    map.put(<span class="number">2</span>,<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));</span><br><span class="line">    map.put(<span class="number">3</span>,<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="keyword">new</span> Person(<span class="string">"赵六"</span>,<span class="number">18</span>));<span class="comment">//key重复,会替代</span></span><br><span class="line">    <span class="comment">//使用keyset遍历集合</span></span><br><span class="line">    <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">        Person value = map.get(key);</span><br><span class="line">        System.out.println(<span class="string">"key:"</span>+key+<span class="string">"--&gt;value:"</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型作为key,必须重写equals()和hashCode()方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key使用自定义类,因为key唯一,必须重写hashCode()和equals方法;</span></span><br><span class="line">    HashMap&lt;Person, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>),<span class="number">1</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>),<span class="number">2</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>),<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//若不重写重写hashCode()和equals方法,重复也会添加</span></span><br><span class="line">    map.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>),<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//使用entrySet()遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Person, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        Person key = entry.getKey();</span><br><span class="line">        Integer value = entry.getValue();</span><br><span class="line">        System.out.println(<span class="string">"key:"</span> + key + <span class="string">"value:"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>LinkedHashMap&lt;k,v&gt;集合  extends HashMap&lt;k,v&gt;</p>
<ul>
<li><strong>有序Map集合</strong></li>
<li>底层原理  哈希表+链表(用来记录元素的顺序)</li>
</ul>
</li>
<li><p>HashTable&lt;k,v&gt; implements Map&lt;k,v&gt; 接口</p>
<ul>
<li><p><strong>键值都不允许存储空值</strong></p>
</li>
<li><p>底层也是一个哈希表</p>
</li>
<li><p>早期的双链集合JDK1.0就有,已被(HashMap)取代,但是<strong>Hashtable的子类Properties依然活跃</strong>于历史舞台,Properties是唯一一个和IO流相结合的集合</p>
</li>
<li><p>同步的,单线程,速度慢,安全</p>
</li>
</ul>
</li>
<li><p>Map集合练习:计算一个字符串每个字符出现的次数</p>
<ul>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/13/1/%E7%94%A8Map%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1%E6%A1%88%E4%BE%8B.png" alt="用Map字符统计案例"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.用户输入字符串</span></span><br><span class="line"><span class="comment">* 2.转换字符串为字符数组</span></span><br><span class="line"><span class="comment">* 3.创建HashMap集合存放[字符]与[对应个数]</span></span><br><span class="line"><span class="comment">* 4.判断key是否存在,若存在,取出value并++,再将value放回,若不存在,新建一个key,并将value设为1</span></span><br><span class="line"><span class="comment">* 5.遍历Map集合</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入一个字符串"</span>);</span><br><span class="line">    String str = scanner.next();</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">        <span class="comment">//判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">            <span class="comment">//对value操作</span></span><br><span class="line">            Integer value = map.get(c);</span><br><span class="line">            value++;</span><br><span class="line">            map.put(c,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不存在创建key</span></span><br><span class="line">            map.put(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">         <span class="keyword">char</span> key = entry.getKey();</span><br><span class="line">         Integer value = entry.getValue();</span><br><span class="line">        System.out.println(key+<span class="string">"有"</span>+value+<span class="string">"个"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<p>JDK9集合添加的新特性</p>
<ul>
<li><p>Lsit接口,Set接口,Map接口:里边增加了一个静态的of()方法,可以给集合一次性添加多个元素</p>
</li>
<li><p>使用前提:当集合中存储的元素个数已经确定了,不在使用时改变</p>
</li>
<li><p>of()方法只适用于Lsit接口,Set接口,Map接口三个接口,不适用于接口的实现类</p>
</li>
<li><p>of()方法的返回值是一个不能改变的集合,集合不能再使用add,put方法,使用会抛出异常</p>
</li>
<li><p>Set接口和Map接口在调用of方法时,不能有重复元素,否则会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>);</span><br><span class="line">    System.out.println(lsit);</span><br><span class="line">    list.add(<span class="string">"e"</span>);<span class="comment">//不能使用,此处会抛不支持操作异常</span></span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>);<span class="comment">//错误,"a"重复,会抛非法参数异常,不允许元素重复</span></span><br><span class="line">    Map&lt;String, Integer&gt; = Map.of(<span class="string">"张三"</span>,<span class="number">18</span>,<span class="string">"李四"</span>,<span class="number">19</span>,<span class="string">"王五"</span>,<span class="number">20</span>);<span class="comment">//正确</span></span><br><span class="line">    map.put(<span class="string">"赵六"</span>,<span class="number">80</span>);<span class="comment">//错误,不能添加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>斗地主案例2:要求实现所发的牌已排好序</p>
</li>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/13/1/%E6%96%97%E5%9C%B0%E4%B8%BB2%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="斗地主2案例分析"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*发牌有序版</span></span><br><span class="line"><span class="comment"> * 1.准备牌</span></span><br><span class="line"><span class="comment"> * 2.洗牌</span></span><br><span class="line"><span class="comment"> * 3.发牌</span></span><br><span class="line"><span class="comment"> * 4.排序</span></span><br><span class="line"><span class="comment"> * 5.发牌</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDizhu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//准备牌</span></span><br><span class="line">        <span class="comment">//创建Map集合,存储牌的索引和组装好的牌</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; poker = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建一个list集合,存储牌的索引</span></span><br><span class="line">        ArrayList&lt;Integer&gt; pokerIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] colors = &#123;<span class="string">"♠"</span>, <span class="string">"♥"</span>, <span class="string">"♣"</span>, <span class="string">"♦"</span>&#125;;</span><br><span class="line">        String[] numbers = &#123;<span class="string">"2"</span>, <span class="string">"A"</span>, <span class="string">"K"</span>, <span class="string">"Q"</span>, <span class="string">"J"</span>, <span class="string">"10"</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"7"</span>, <span class="string">"6"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>, <span class="string">"3"</span>,&#125;;</span><br><span class="line">        <span class="comment">//设置一个索引值,添加大小王</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        poker.put(index, <span class="string">"大王"</span>);</span><br><span class="line">        pokerIndex.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        poker.put(index, <span class="string">"小王"</span>);</span><br><span class="line">        pokerIndex.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">//向poker中添加元素</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                poker.put(index, color + number);</span><br><span class="line">                pokerIndex.add(index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看牌与牌索引</span></span><br><span class="line">        System.out.println(poker);</span><br><span class="line">        System.out.println(pokerIndex);</span><br><span class="line">        <span class="comment">//打乱牌</span></span><br><span class="line">        Collections.shuffle(pokerIndex);</span><br><span class="line">        <span class="comment">//发牌 四个集合存玩家和底牌</span></span><br><span class="line">        ArrayList&lt;Integer&gt; play01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; play02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; play03 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; dipai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历索引获取牌,向玩家集合添加牌</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pokerIndex.size(); i++) &#123;</span><br><span class="line">            Integer p = pokerIndex.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                dipai.add(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//给玩家1发牌</span></span><br><span class="line">                play01.add(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//给玩家2发牌</span></span><br><span class="line">                play02.add(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//给玩家3发牌</span></span><br><span class="line">                play03.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(play01);</span><br><span class="line">        Collections.sort(play02);</span><br><span class="line">        Collections.sort(play03);</span><br><span class="line">        Collections.sort(dipai);</span><br><span class="line">        lookPoker(<span class="string">"刘德华"</span>, poker, play01);</span><br><span class="line">        lookPoker(<span class="string">"周润发"</span>, poker, play02);</span><br><span class="line">        lookPoker(<span class="string">"周星驰"</span>, poker, play03);</span><br><span class="line">        lookPoker(<span class="string">"底牌"</span>, poker, dipai);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代码重用,定义一个看牌的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookPoker</span><span class="params">(String name, HashMap&lt;Integer, String&gt; poker, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.print(name + <span class="string">": "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer key : list) &#123;</span><br><span class="line">            String value = poker.get(key);</span><br><span class="line">            System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">laden</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lqhao.gitee.io/2020/07/13/1/">http://lqhao.gitee.io/2020/07/13/1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lqhao.gitee.io" target="_blank">不蒸馒头争口气</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Collection/">Collection</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/weixinpay.jpg" alt="微信" onclick="window.open('https://gitee.com/lqhao/img-bed/raw/master/img-page/weixinpay.jpg')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/alipay.jpg" alt="支付宝" onclick="window.open('https://gitee.com/lqhao/img-bed/raw/master/img-page/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/15/1/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java-异常、线程</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/10/2/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java-基本引用类型的使用</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/25/2/" title="Java-JDBC连接池、JDBCTemplate"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-25</div><div class="relatedPosts_title">Java-JDBC连接池、JDBCTemplate</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/08/1/" title="Java-API-说明文档推荐"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-08</div><div class="relatedPosts_title">Java-API-说明文档推荐</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/20/2/" title="Java-Stream流"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-20</div><div class="relatedPosts_title">Java-Stream流</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By laden</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>