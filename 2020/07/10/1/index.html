<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java-面向对象笔记 | 不蒸馒头争口气</title><meta name="description" content="面向对象三大特征：封装、继承、多态封装性封装就是将一些细节信息隐藏起来，对于外界不可见 1.方法就是一种封装 2.关键字private也是一种封装 ​        一旦使用private进行修饰，本类之中仍可正常访问，类外将不能直接访问  ​        间接访问成员变量就是使用例setAge()、getAge()方法，即Getter Setter 方法 ​        * 注意 当返回值是"><meta name="keywords" content="Java"><meta name="author" content="laden"><meta name="copyright" content="laden"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lqhao.gitee.io/2020/07/10/1/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Java-面向对象笔记"><meta property="og:url" content="http://lqhao.gitee.io/2020/07/10/1/"><meta property="og:site_name" content="不蒸馒头争口气"><meta property="og:description" content="面向对象三大特征：封装、继承、多态封装性封装就是将一些细节信息隐藏起来，对于外界不可见 1.方法就是一种封装 2.关键字private也是一种封装 ​        一旦使用private进行修饰，本类之中仍可正常访问，类外将不能直接访问  ​        间接访问成员变量就是使用例setAge()、getAge()方法，即Getter Setter 方法 ​        * 注意 当返回值是"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-10T11:47:59.747Z"><meta property="article:modified_time" content="2020-07-22T13:37:10.051Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Java-基本引用类型的使用" href="http://lqhao.gitee.io/2020/07/10/2/"><link rel="next" title="Java-API-说明文档推荐" href="http://lqhao.gitee.io/2020/07/08/1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/04232036663275.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象三大特征：封装、继承、多态"><span class="toc-number">1.</span> <span class="toc-text">面向对象三大特征：封装、继承、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#封装性"><span class="toc-number">1.1.</span> <span class="toc-text">封装性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一个标准的类四部分组成"><span class="toc-number">1.1.1.</span> <span class="toc-text">一个标准的类四部分组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名对象"><span class="toc-number">1.1.2.</span> <span class="toc-text">匿名对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承性"><span class="toc-number">1.2.</span> <span class="toc-text">继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承关系当中的特点："><span class="toc-number">1.2.1.</span> <span class="toc-text">继承关系当中的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写（关键字：-Override-是一个可选的安全检测手段，可写可不写）"><span class="toc-number">1.2.2.</span> <span class="toc-text">重写（关键字：@Override  是一个可选的安全检测手段，可写可不写）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承关系中父子类构造方法的关系"><span class="toc-number">1.2.3.</span> <span class="toc-text">继承关系中父子类构造方法的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super总结（用来访问父类内容）"><span class="toc-number">1.2.4.</span> <span class="toc-text">super总结（用来访问父类内容）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this总结（用了访问本类内容）"><span class="toc-number">1.2.5.</span> <span class="toc-text">this总结（用了访问本类内容）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象"><span class="toc-number">1.2.6.</span> <span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口类"><span class="toc-number">1.2.7.</span> <span class="toc-text">接口类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承总结"><span class="toc-number">1.2.8.</span> <span class="toc-text">继承总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态性-（Polymorphism）"><span class="toc-number">1.3.</span> <span class="toc-text">多态性 （Polymorphism）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问成员变量规则（同继承一样）"><span class="toc-number">1.3.1.</span> <span class="toc-text">访问成员变量规则（同继承一样）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问成员方法规则（同继承也一样）"><span class="toc-number">1.3.2.</span> <span class="toc-text">访问成员方法规则（同继承也一样）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态的好处"><span class="toc-number">1.3.3.</span> <span class="toc-text">多态的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态的上下转型"><span class="toc-number">1.3.4.</span> <span class="toc-text">多态的上下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-关键字-代表最终，不可改变的"><span class="toc-number">1.3.5.</span> <span class="toc-text">final 关键字  代表最终，不可改变的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四种权限修饰符"><span class="toc-number">1.3.6.</span> <span class="toc-text">四种权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">1.3.7.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类作为成员变量类型"><span class="toc-number">1.3.8.</span> <span class="toc-text">类作为成员变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口作为成员变量类型"><span class="toc-number">1.3.9.</span> <span class="toc-text">接口作为成员变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口作为方法的参数或返回值"><span class="toc-number">1.3.10.</span> <span class="toc-text">接口作为方法的参数或返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的权限修饰符"><span class="toc-number">1.4.</span> <span class="toc-text">类的权限修饰符</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">不蒸馒头争口气</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java-面向对象笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-10 19:47:59"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-22 21:37:10"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-22</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">5.8k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 19 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="面向对象三大特征：封装、继承、多态"><a href="#面向对象三大特征：封装、继承、多态" class="headerlink" title="面向对象三大特征：封装、继承、多态"></a>面向对象三大特征：封装、继承、多态</h1><h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><p><strong>封装就是将一些细节信息隐藏起来，对于外界不可见</strong></p>
<p>1.方法就是一种封装</p>
<p>2.关键字private也是一种封装</p>
<p>​        一旦使用private进行修饰，本类之中仍可正常访问，类外将不能直接访问 </p>
<p>​        间接访问成员变量就是使用例setAge()、getAge()方法，即Getter Setter 方法</p>
<p>​        * 注意 当返回值是Boolean类型时他的Getter方法必须使用isXxx()方法</p>
<h3 id="一个标准的类四部分组成"><a href="#一个标准的类四部分组成" class="headerlink" title="一个标准的类四部分组成"></a>一个标准的类四部分组成</h3><p>​    1.所有成员变量都要使用private关键词修饰</p>
<p>​    2.为每一个变量编写一对Getter/Setter方法</p>
<p>​    3.编写一个无参构造方法</p>
<p>​    4.编写一个全参构造方法</p>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><ul>
<li>如果确定一个对象只需要使用唯一的一次，可使用匿名对象</li>
<li>直接   new Person（）；新建实例</li>
<li>使用成员变量   new Person（）.name = “XXX”;</li>
<li>匿名对象只能使用唯一的一次，下次使用必须重新new</li>
<li>使用匿名对象  eg:   Scanner <ul>
<li>int num = new Scanner（System.in）.nextInt();</li>
</ul>
</li>
<li>使用匿名对象传参<ul>
<li>method（new Scanner(Systen.in)）;</li>
</ul>
</li>
<li>匿名对象也可当返回值<ul>
<li>return new Scanner（System.in）；</li>
</ul>
</li>
</ul>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><ul>
<li><p>继承是多态的前提，如果没有继承，就没有多态</p>
</li>
<li><p>继承主要解决的问题就是：<font color="red">共性抽取</font></p>
</li>
<li><p>父类：也称为基类、超类</p>
</li>
<li><p>子类：也可以叫做派生类</p>
</li>
</ul>
<h3 id="继承关系当中的特点："><a href="#继承关系当中的特点：" class="headerlink" title="继承关系当中的特点："></a>继承关系当中的特点：</h3><ul>
<li>子类可以拥有父类授权的“内容”</li>
<li>子类还可以拥有自己专有的内容</li>
<li>Java的<strong>extends是单继承</strong>，一个类的直接父类只能有一个</li>
<li>Java可以多级继承，子类有父类，父类也可以有父类</li>
<li><img src= "/img/loading.gif" data-src="/2020/07/10/1/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="继承关系"></li>
</ul>
<ul>
<li><p>在继承关系中，“子类就是一个父类”</p>
<ul>
<li>列如：父类是员工，子类是讲师，那么“讲师就是一个员工”</li>
</ul>
</li>
<li><p>在父子类的继承关系中，<strong>若成员变量重名</strong>，则创建子类对象时，访问有两种方式：</p>
<ul>
<li>直接通过子类对象访问成员变量<ul>
<li><strong>等号左边</strong>是谁就优先用谁，没有则向上找</li>
</ul>
</li>
<li>间接通过成员方法访问成员变量<ul>
<li><strong>该方法属于谁</strong>，就优先用谁，没有则向上找</li>
</ul>
</li>
</ul>
</li>
<li><p>局部变量，子类成员变量，父类成员变量均重名，访问父类成员变量用super关键字</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/10/1/%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D.png" alt="变量重名"></p>
</li>
<li><p>父子类的继承关系中，访问重名成员方法访问规则</p>
<ul>
<li>创建的对象是谁，就优先用谁，若没有则向上找</li>
</ul>
</li>
</ul>
<h3 id="重写（关键字：-Override-是一个可选的安全检测手段，可写可不写）"><a href="#重写（关键字：-Override-是一个可选的安全检测手段，可写可不写）" class="headerlink" title="重写（关键字：@Override  是一个可选的安全检测手段，可写可不写）"></a>重写（关键字：@Override  是一个可选的安全检测手段，可写可不写）</h3><ul>
<li><p>在继承关系当中，方法的名称一样，参数列表也一样</p>
</li>
<li><p>重写（Override）：方法的名称一样，参数列表【也一样】。覆盖、覆写。</p>
</li>
<li><p>重载（Overload）：方法的名称一样，参数列表【不一样】</p>
</li>
<li><p>特点</p>
<ul>
<li>创建的是子类，则优先用子类方法</li>
</ul>
</li>
<li><p>子类方法的返回值必须【小于等于】父类方法的返回值范围</p>
</li>
<li><p>子类方法的权限，必须【大于等于】父类方法的权限修饰符</p>
<ul>
<li>public &gt; protected &gt; (default) &gt; private<ul>
<li>default不是关键字default，而是留空，例如：int a；</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/2020/07/10/1/%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99.png" alt="继承重写"></p>
</li>
<li><p>子类中，使用<font color="red">super.方法名，</font>把父类的该方法的内容重复利用</p>
<p><img src= "/img/loading.gif" data-src="/2020/07/10/1/%E9%87%8D%E5%86%99super%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="重写super关键字"></p>
</li>
</ul>
<h3 id="继承关系中父子类构造方法的关系"><a href="#继承关系中父子类构造方法的关系" class="headerlink" title="继承关系中父子类构造方法的关系"></a>继承关系中父子类构造方法的关系</h3><ul>
<li>子类构造方法当中有一个隐含的<code>super();</code>调用，所以一定先调用父类构造，后执行子类构造。</li>
<li>子类构造可以用过super（参数）关键字来调用父类重载构造。</li>
<li>super（）的父类构造方法调用，必须是子类构造方法的第一个语句，子类成员方法不可调用，不能一个子类构造调用多次super（）构造。</li>
<li>子类必须调用父类构造方法，不写则赠送super(),写了则用写的指定的super()调用，super()只能有一个，还必须是第一句。</li>
</ul>
<h3 id="super总结（用来访问父类内容）"><a href="#super总结（用来访问父类内容）" class="headerlink" title="super总结（用来访问父类内容）"></a>super总结（用来访问父类内容）</h3><ul>
<li>在子类的成员的方法中访问父类的成员变量。super.a</li>
<li>在子类的成员方法中，继承父类的成员方法。super.method()</li>
<li>在子类的构造方法中，继承父类的构造方法。super(参数)</li>
</ul>
<h3 id="this总结（用了访问本类内容）"><a href="#this总结（用了访问本类内容）" class="headerlink" title="this总结（用了访问本类内容）"></a>this总结（用了访问本类内容）</h3><ul>
<li>在本类的成员方法中，访问本类的成员变量。this.a</li>
<li>在本类的成员方法中，访问本类的另一个成员方法。this.method()</li>
<li>在本类的构造方法中，访问本类的另一个构造方法。this(参数)必须是第一个语句，也是唯一个</li>
</ul>
<ul>
<li><p>构造方法super，this注意</p>
<ul>
<li>构造方法中super()或this()必须是第一个语句，也是唯一一个</li>
<li>构造方法中super()和this()关键字不能同时使用</li>
<li><img src= "/img/loading.gif" data-src="/2020/07/10/1/super_this%E5%86%85%E5%AD%98.png" alt="super_this内存"></li>
</ul>
</li>
</ul>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul>
<li>如果父类当中的方法不确定{…}中内容如何实现，那么这样的方法就叫做抽象方法</li>
<li><strong>加上abstract关键字，去掉大括号就是抽象方法</strong>  public abstract void eat();</li>
<li><strong>有抽象方法的是抽象类</strong>，需在class前写abstract关键字，public abstract class Animal{…}</li>
<li>不能直接创建抽象类对象，只能用一个子类继承抽象父类</li>
<li>子类必须覆盖重写父抽象类的<strong>所有</strong>抽象方法，并去掉abstract关键字</li>
<li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类使用的，子类的构造方法中有默认的super()方法调用父类构造方法</li>
<li><strong>抽象类中不一定有抽象方法</strong></li>
</ul>
<h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><ul>
<li><p>接口就是一种公共的规范标准，只要符合规范标准，就可以大家通用</p>
</li>
<li><p>接口是一种引用数据类型，最重要的内容就是其中的抽象方法</p>
</li>
<li><p>接口中可以包含的：</p>
<ul>
<li>Java7 <ul>
<li>常量</li>
<li>抽象方法</li>
</ul>
</li>
<li>Java8（super Java7）<ul>
<li>默认方法</li>
<li>静态方法</li>
</ul>
</li>
<li>Java9（super Java8）<ul>
<li>私有方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoIntterface</span></span>&#123;</span><br><span class="line">	<span class="comment">//抽象方法，关键词使用public abstract，这两个关键字可以选择性的省略,以下都属于抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认方法定义格式,默认方法可以解决接口升级的问题,如想在接口中添加新的方法，但又不能影响已经继承过该接口的类的使用。在继承过该接口类的实例中，可以调用接口类中后添加的默认方法，默认方法类似于普通继承，默认方法也可被实现类覆盖重写</span></span><br><span class="line">    <span class="comment">//接口的默认方法也可拼接函数模型</span></span><br><span class="line">    <span class="comment">//public关键字可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    接口中的静态方法</span></span><br><span class="line"><span class="comment">    通过接口类的名称，直接调用其中的静态方法:接口类.静态方法(),不能使用实例名.方法名调用</span></span><br><span class="line"><span class="comment">    public关键字可以省略</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*接口的私有方法</span></span><br><span class="line"><span class="comment">    若接口类中需要抽取一个公共方法，用来解决两个默认方法之间代码重复的问题。但这个共有方法不应该让实现类使用，应该是私有化的</span></span><br><span class="line"><span class="comment">    Java9开始允许定义私有方法</span></span><br><span class="line"><span class="comment">    	1.普通私有方法：解决多个默认方法之间代码重复问题</span></span><br><span class="line"><span class="comment">    	2.静态私有方法：解决多个静态方法之间代码重复问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口使用步骤</p>
<ul>
<li><p>接口不能直接使用，<strong>必须有一个实现类来实现接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口的实现必须覆盖重写（实现）接口中的所有抽象方法。实现：去掉abstract关键字，加上方法体大括号</p>
</li>
<li><p>如果实现类并没有覆盖重写接口中的所有抽象方法，那么这个实现类自己就必须是抽象类</p>
</li>
</ul>
</li>
<li><p>接口当中也可以定义<strong>“成员变量”</strong>，但必须使用[public] [static] [final] 三个关键字进行修饰,这三个关键字也可省略，<strong>变量名使用大写用下划线分割，接口中的常量必须进行赋值，一旦赋值不可修改。</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">10</span>;</span><br><span class="line">      <span class="comment">//因关键字可省略，完全等效于  int NUM = 20;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用接口时需要注意</p>
<ul>
<li><p>接口<strong>没有静态代码块或构造方法</strong>，因为接口不能<strong>new</strong></p>
</li>
<li><p>一个类的直接父类是唯一的，但是<strong>一个类可以同时实现多个接口</strong></p>
</li>
<li><p>如果实现类所有实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可</p>
</li>
<li><p>如果实现类没有覆盖重写所有接口类的所有抽象方法，那实现类必须是抽象类</p>
</li>
<li><p>如果实现类的多个接口中，存在重复的默认方法，那么实现类一定要对该默认方法重写</p>
</li>
<li><p>一个类如果直接父类中的方法，和接口中的方法产生冲突，优先使用父类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">//需要写两接口的所有抽象方法，或者该类是抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="comment">//若继承的抽象方法中有重名的抽象方法，重写一个即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="comment">//若继承的抽象方法中有重名的默认方法，必须重写该默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处的methodDefault优先使用父类的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="继承总结"><a href="#继承总结" class="headerlink" title="继承总结"></a>继承总结</h3><ul>
<li><p>类与类之间是单继承的，直接父类只能有一个</p>
</li>
<li><p>类与接口之间是多实现的，一个类可以实现多个接口</p>
</li>
<li><p>接口与接口之间是多继承的</p>
</li>
<li><p>注意事项：</p>
<ul>
<li>多个父接口当中的<strong>抽象方法</strong>如果重复，没关系，因为抽象方法没有实现，只是抽象而已</li>
<li>多个父接口当中的<strong>默认方法</strong>如果重复，那么子接口必须对该默认方法进行重写，而且带有default关键字 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口与接口之间可以是多继承的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//多个父接口当中的默认方法如果重复，那么子接口必须对默认方法进行重写</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<p>​        </p>
<h2 id="多态性-（Polymorphism）"><a href="#多态性-（Polymorphism）" class="headerlink" title="多态性 （Polymorphism）"></a>多态性 （Polymorphism）</h2><ul>
<li><p><strong>extends继承或者implements实现，是多态性的前提</strong></p>
</li>
<li><p>代码中体现多态性，其实就是一句话，<strong>父类引用指向子类对象</strong></p>
<ul>
<li>父类名称  对象名 = new 子类名称（）</li>
<li>接口名称  对象名 = new 实现类名称（）</li>
<li>右侧子类对象当作父类使用</li>
</ul>
</li>
</ul>
<h3 id="访问成员变量规则（同继承一样）"><a href="#访问成员变量规则（同继承一样）" class="headerlink" title="访问成员变量规则（同继承一样）"></a>访问成员变量规则（同继承一样）</h3><ul>
<li><p>直接通过子类对象访问成员变量</p>
<ul>
<li><strong><font color="red">等号左边</font></strong>是谁就优先用谁，没有则向上找</li>
</ul>
</li>
<li><p>间接通过成员方法访问成员变量</p>
<ul>
<li><strong><font color="red">该方法属于谁，</font></strong>就优先用谁，没有则向上找</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();  <span class="comment">//等号左边是A父类</span></span><br><span class="line">        System.out.println(obj.num) <span class="comment">//访问的是等号左边的A类的num</span></span><br><span class="line">        System.out.println(obj.age)  <span class="comment">//obj中无age属性,错误写法，报错</span></span><br><span class="line">        <span class="comment">//子类没有覆盖重写，就使用父</span></span><br><span class="line">        <span class="comment">//此处子类该方法被重写，属于B，优先使用B</span></span><br><span class="line">        obj.showNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="访问成员方法规则（同继承也一样）"><a href="#访问成员方法规则（同继承也一样）" class="headerlink" title="访问成员方法规则（同继承也一样）"></a>访问成员方法规则（同继承也一样）</h3><ul>
<li><strong>看new</strong>的是谁，就优先用谁，没有则向上找</li>
</ul>
<ul>
<li><p>口诀</p>
<ul>
<li><p>成员变量：编译看左边，运行还看左边</p>
</li>
<li><p>成员方法：编译看左边，运行看右边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">metoodFu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">metoodZi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();  <span class="comment">//等号左边是A父类</span></span><br><span class="line">      	<span class="comment">//</span></span><br><span class="line">   		obj.method();<span class="comment">//父子都有，new的是子，优先用子</span></span><br><span class="line">      	obj.methodFu();<span class="comment">//子类没有，父类有，向上找到父类</span></span><br><span class="line">      	<span class="comment">//编译看左边，左边是父类，父类中没有methodZi()方法，所以编译报错</span></span><br><span class="line">      	obj.methodZi();<span class="comment">//编译不通过，不能访问，错误写法 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ul>
<li><strong>可以使无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化</strong></li>
<li><img src= "/img/loading.gif" data-src="/2020/07/10/1/%E5%A4%9A%E6%80%81%E5%A5%BD%E5%A4%84.png" alt="多态好处"></li>
</ul>
<h3 id="多态的上下转型"><a href="#多态的上下转型" class="headerlink" title="多态的上下转型"></a>多态的上下转型</h3><ul>
<li><p><strong>对象的向上转型</strong></p>
<ul>
<li>格式：父类名称  对象名 = new 子类名称（）</li>
<li>含义：创建一个子类对象，把他当作父类来看待使用。父类引用指向子类对象。</li>
<li><strong>向上转型一定是安全的</strong>，因为从子类的小范围转向了父类的大范围。</li>
<li>一旦向上转型位父类，那么就无法调用子类原有的特性</li>
</ul>
</li>
<li><p><strong>对象的向下转型</strong></p>
<ul>
<li><p>其实是一个还原的动作</p>
</li>
<li><p>子类名称 对象名 = （子类名称）父类对象；</p>
</li>
<li><p>含义，将父类对象【还原】为本来的鹅子类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();<span class="comment">//本来是猫，向上转型成动物</span></span><br><span class="line">Cat cat = (Cat)animal;<span class="comment">//本来是猫，已经被当成动物了，还原成为本来的猫</span></span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">  a.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。</span><br><span class="line">  b.如果对象创建的时候本来不是猫，非要向下转型为猫，就会报错</span><br><span class="line">    Animal animal = <span class="keyword">new</span> Dog();本来是狗，向上转型成动物</span><br><span class="line">      Cat cat = (Cat)animal;<span class="comment">//本来是猫，向下转型为狗，报错,ClassCastException 类转换错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/10/1/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B.png" alt="对象的上下转型"></p>
</li>
</ul>
</li>
<li><p><strong>如何才能知道一个父类引用的对象，本来是什么子类</strong></p>
<ul>
<li><p>格式：  对象  <code>instanceof</code>   类名称</p>
</li>
<li><p>将会得到一个Boolean值结果，也就是判断前面的的对象能不能当作后面类型的实例</p>
</li>
<li><pre><code class="java">    Animal animal = <span class="keyword">new</span> Cat();<span class="comment">//本来是猫</span>
    animal.eat();<span class="comment">//猫吃鱼</span>

    <span class="comment">//判断父类引用本来是不是Dog</span>
    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog){
        Dog dog = (Dog) animal;
        dog.watchHouse();
    }
    <span class="comment">//判断animal本来是不是Cat</span>
    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat){
        Cat cat = (Cat) animal;
        cat.catchMouse();
    }
&lt;!--￼<span class="number">9</span>--&gt;




</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="final-关键字-代表最终，不可改变的"><a href="#final-关键字-代表最终，不可改变的" class="headerlink" title="final 关键字  代表最终，不可改变的"></a>final 关键字  代表最终，不可改变的</h3><ol>
<li><p>可以用来修饰一个类</p>
<ul>
<li><code>public final class 类名称{ //... }</code></li>
<li>含义：当前这个类不能有任何的子类</li>
<li>可以有父类</li>
<li>注意：一个类是final的，那么其中所有的成员方法都不能被重写，因为没有子类</li>
</ul>
</li>
<li><p>可以用来修饰一个方法</p>
<ul>
<li><code>修饰符 final 返回值类型 方法名称（参数列表）{//...}</code></li>
<li>含义：当前方法是最终方法，不能被子类覆盖重写</li>
<li>对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾，<ul>
<li>abstract  中的方法必须被【覆盖重写】</li>
<li>final  中的方法必须【不被覆盖重写】</li>
</ul>
</li>
</ul>
</li>
<li><p>可以用于修饰一个局部变量</p>
<ul>
<li><p>final 类型 变量 = 固定值；</p>
</li>
<li><p>一旦使用final来修饰局部变量，那么这个变量就不能进行更改，”一次赋值，终身不变“</p>
</li>
<li><p>对于基本类型来说，不可变说的是变量当中的数据不可变</p>
</li>
<li><p>对于引用类型来说，不可变说的是变量当中的地址值不可变</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">3</span>; <span class="comment">//基本类型正确赋值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num2;</span><br><span class="line">num2 = <span class="number">5</span>; <span class="comment">//基本类型正确赋值，只要保证唯一一次赋值即可</span></span><br><span class="line"><span class="keyword">final</span> Student stu = <span class="keyword">new</span> Student(<span class="string">"赵丽颖"</span>);<span class="comment">//引用类型，此stu实例不可重行赋值，final修饰后，实例地址不可变</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可以用来修饰一个成员变量</p>
<ul>
<li><p>对于成员变量，如果使用final关键字修饰，那么这个变量也照样是不可变的。</p>
<ul>
<li><p>由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。</p>
</li>
<li><p>对于final的成员变量，要么直接赋值，要么通过构造方法赋值（要保证类当中所有重载构造方法都对 final 成员变量进行赋值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">18</span>; <span class="comment">//1.没有默认值，必须进行赋值。</span></span><br><span class="line">    <span class="keyword">final</span> String name;<span class="comment">//2.通过构造方法赋值,必须进行赋值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"赵丽颖"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String name )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">public     &gt;     protected     &gt;     (default  啥都不写)    &gt;    private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一个类 （我自己）</td>
<td align="center">YES                   YES                            YES                          YES</td>
</tr>
<tr>
<td align="center">同一个包（我领居）</td>
<td align="center">YES                   YES                             YES                          NO</td>
</tr>
<tr>
<td align="center">不同包子类 （我儿子）</td>
<td align="center">YES                   YES                              NO                           NO</td>
</tr>
<tr>
<td align="center">不同包非子类 （陌生人）</td>
<td align="center">YES                    NO                               NO                           NO</td>
</tr>
</tbody></table>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li><p>如果一个事物的内部包含另一个事物，那么这就是一个内部包含另一个类，例如：身体和心脏的关系，又如：汽车和发动机的关系</p>
</li>
<li><p>分类</p>
<ul>
<li><p>成员内部类</p>
<ul>
<li><p>定义格式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称 </span>&#123; </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    修饰符 <span class="class"><span class="keyword">class</span> 内部类名称 </span>&#123; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内用外，随意访问，外用内，一定需要借助内部类对象</strong></p>
</li>
<li><p>生成的.class文件</p>
<ul>
<li><img src= "/img/loading.gif" data-src="/2020/07/10/1/%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84class.png" alt="内部类的class"></li>
</ul>
</li>
<li><p>成员内部类使用</p>
<ul>
<li><p>直接方式：再外部类的方法中，创建内部类实例，然后main只是调用外部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;<span class="comment">//成员内部类</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类方法"</span>);</span><br><span class="line">            System.out.println(name);<span class="comment">//正确写法，能访问name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类方法"</span>);</span><br><span class="line">        <span class="keyword">new</span> Heart().beat();<span class="comment">//外部类中直接使用内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main中使用:</span><br><span class="line">   Body body = <span class="keyword">new</span> Body();</span><br><span class="line">   body.methodBody();<span class="comment">//能够间接访问内部类</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接方式：公式：外.内</p>
<ul>
<li><p>格式     外部类名称.内部类名称   对象名  =  new   外部类名称().new 内部类名称()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main中使用:</span><br><span class="line">	Body.<span class="function">Heart heart new <span class="title">Body</span><span class="params">()</span>.new <span class="title">heart</span><span class="params">()</span></span>;<span class="comment">//直接创建内部类对象</span></span><br><span class="line">	heart.beat();<span class="comment">//直接调用内部类</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果出现了重名现象</strong>，那么格式是，<strong>外部类名称.this.变量名称</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;<span class="comment">//外部类成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;<span class="comment">//内部类成员变量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>;<span class="comment">//内部类方法的局部变量</span></span><br><span class="line">            System.out.println(num);<span class="comment">//30</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);<span class="comment">//内部类的成员变量20</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);<span class="comment">//10内部类访问外部类成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>局部内部类（包含匿名内部类）</p>
<ul>
<li><p>如果一个类是定义再一个方法内部的，那么这就是一个局部内部类，只有当前所属的方法才能使用它，出了这个方法就不能用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义格式</span></span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称</span>&#123;</span><br><span class="line">    修饰符 返回值类型 外部类方法名称(参数列表)&#123;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> 局部内部类名称</span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; <span class="comment">//外部类名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span> </span>&#123; <span class="comment">//外部类方法</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;<span class="comment">//局部内部类的方法</span></span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner =<span class="keyword">new</span> Inner();<span class="comment">//局部内部类使用</span></span><br><span class="line">        inner.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main中使用:</span><br><span class="line">	Outer obj = <span class="keyword">new</span> Outer();</span><br><span class="line">	obj.methodOuter();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：局部内部类，如果希望访问所在的方法的局部变量，那么这个局部变量必须是【有效的final】关键字定义的，从java8+开始，只要局部变量事实不变，则final关键字可以省略。</p>
<ul>
<li>原因<ul>
<li>new出来的对象在堆内存当中</li>
<li>局部变量是跟着方法走的，在栈内存中</li>
<li>方法运行结束后，立刻出栈，局部变量就会立刻消失</li>
<li>但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。</li>
<li>inner对象活的时间久</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">       <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">       <span class="keyword">int</span> num3 = <span class="number">30</span>;</span><br><span class="line">       num3 = <span class="number">40</span>;<span class="comment">//报错</span></span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;<span class="comment">//此局部内部类属于methodMOuter()方法</span></span><br><span class="line">          </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;<span class="comment">//此方法属于局部内部类</span></span><br><span class="line">                System.out.println(num1);<span class="comment">//此处可以访问num1</span></span><br><span class="line">                System.out.println(num2);<span class="comment">//正确访问，num2没变化，java8+特性</span></span><br><span class="line">                System.out.println(num3);<span class="comment">//出错，num3变化了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner =<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>匿名内部类（重点）</strong></p>
<ul>
<li><p>如果接口的实现类（或者是父类的子类），只需要使用唯一的一次，那么这种情况下就可以省略该类的定义，而改为使用【匿名内部类】</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类格式</span></span><br><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称()&#123;</span><br><span class="line">    <span class="comment">//覆盖重写所有的抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;<span class="comment">//定义接口类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main中使用(重点):</span><br><span class="line">	<span class="comment">//main方法中使用匿名内部类实现该接口的抽象方法</span></span><br><span class="line">	MyInterface obj = <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"接口实现"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">	obj.method();</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 格式解析:   “new 接口名称(){...}；”

    - new 代表创建对象的动作
    - 接口名称就是匿名内部类需要实现哪个接口
  - {...} 这才是匿名内部类的内容

- 注意事项

  - 使用场景：只对接口进行唯一一次实现

  - 匿名内部类在【创建对象】的时候，**只能使用一次**,如果希望多次创建对象，而且类的内容一样的话，那就就得尽量使用单独定义的实现类了

  - 匿名对象，在【调用方法】的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，那么必须给对象起个名字

  - 匿名内部类是省略了【实现类/子类对象】，但是你梦对象是省略了【对象名称】，强调，你梦内部类和匿名对象不是一回事！！！

      <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用了匿名内部类，而且还使用了匿名对象</span></span><br><span class="line"><span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口实现"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;.obj.method();<span class="comment">//此处使用了匿名对象调用方法</span></span><br><span class="line"><span class="comment">//若还要调用其他方法，还需要重写创建匿名内部类。</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="类作为成员变量类型"><a href="#类作为成员变量类型" class="headerlink" title="类作为成员变量类型"></a>类作为成员变量类型</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口作为成员变量类型"><a href="#接口作为成员变量类型" class="headerlink" title="接口作为成员变量类型"></a>接口作为成员变量类型</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main中使用匿名内部类实现：</span><br><span class="line">    A a1= <span class="keyword">new</span> A()&#123;<span class="comment">//使用匿名内部类实现</span></span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">   		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">       		 <span class="comment">//...</span></span><br><span class="line">   		 &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">	b.a = a1;</span><br><span class="line">或者同时使用匿名对象和匿名内部类：</span><br><span class="line">    B b = <span class="keyword">new</span> B(<span class="keyword">new</span> A()&#123;<span class="comment">//同时使用匿名对象和匿名内部类,B的构造方法传入的参数是A类的对象</span></span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">   		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">       		 <span class="comment">//...</span></span><br><span class="line">   		 &#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="接口作为方法的参数或返回值"><a href="#接口作为方法的参数或返回值" class="headerlink" title="接口作为方法的参数或返回值"></a>接口作为方法的参数或返回值</h3><ul>
<li><img src= "/img/loading.gif" data-src="/2020/07/10/1/%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt="接口作为方法参数和返回值"></li>
</ul>
<h2 id="类的权限修饰符"><a href="#类的权限修饰符" class="headerlink" title="类的权限修饰符"></a>类的权限修饰符</h2><ul>
<li>定义一个类的时候，权限修饰符规则<ul>
<li>外部类  只能使用   public  或者（default  不写）</li>
<li>成员内部类    public / protected  / （default） / private</li>
<li>局部内部类    <strong>什么都不能写，</strong>但效果也不同于不写default)</li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">laden</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lqhao.gitee.io/2020/07/10/1/">http://lqhao.gitee.io/2020/07/10/1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lqhao.gitee.io" target="_blank">不蒸馒头争口气</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/weixinpay.jpg" alt="微信" onclick="window.open('https://gitee.com/lqhao/img-bed/raw/master/img-page/weixinpay.jpg')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/alipay.jpg" alt="支付宝" onclick="window.open('https://gitee.com/lqhao/img-bed/raw/master/img-page/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/10/2/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java-基本引用类型的使用</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/08/1/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java-API-说明文档推荐</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/25/2/" title="Java-JDBC连接池、JDBCTemplate"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-25</div><div class="relatedPosts_title">Java-JDBC连接池、JDBCTemplate</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/08/1/" title="Java-API-说明文档推荐"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-08</div><div class="relatedPosts_title">Java-API-说明文档推荐</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/20/2/" title="Java-Stream流"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-20</div><div class="relatedPosts_title">Java-Stream流</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By laden</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>