<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java-异常、线程 | 不蒸馒头争口气</title><meta name="description" content="Debug调试程序 可以让代码逐行执行,查看代码执行的过程,调试程序出现的Debug 使用方式 可以在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug,添加到哪里) 右键选择debug执行程序,程序就学会停留在添加的第一个断点处   执行程序 F8: 逐行执行程序 F7: 进入到方法中 shift+F8  跳出方法 F9 : 跳到下一个断点,如果没有下一个断电,那么就结束程序 c"><meta name="keywords" content="Java,Exception,Thread"><meta name="author" content="laden"><meta name="copyright" content="laden"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lqhao.gitee.io/2020/07/15/1/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Java-异常、线程"><meta property="og:url" content="http://lqhao.gitee.io/2020/07/15/1/"><meta property="og:site_name" content="不蒸馒头争口气"><meta property="og:description" content="Debug调试程序 可以让代码逐行执行,查看代码执行的过程,调试程序出现的Debug 使用方式 可以在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug,添加到哪里) 右键选择debug执行程序,程序就学会停留在添加的第一个断点处   执行程序 F8: 逐行执行程序 F7: 进入到方法中 shift+F8  跳出方法 F9 : 跳到下一个断点,如果没有下一个断电,那么就结束程序 c"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-15T09:17:27.111Z"><meta property="article:modified_time" content="2020-07-22T13:30:42.959Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Java-Lambda表达式" href="http://lqhao.gitee.io/2020/07/15/3/"><link rel="next" title="Java-日期、System类、Collection集合" href="http://lqhao.gitee.io/2020/07/13/1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/04232036663275.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug调试程序"><span class="toc-number">1.</span> <span class="toc-text">Debug调试程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-number">2.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常体系"><span class="toc-number">2.1.</span> <span class="toc-text">异常体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw关键字"><span class="toc-number">2.2.</span> <span class="toc-text">throw关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Objecs非空判断"><span class="toc-number">2.3.</span> <span class="toc-text">Objecs非空判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理"><span class="toc-number">2.4.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#throws"><span class="toc-number">2.4.1.</span> <span class="toc-text">throws</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-…-catch-…"><span class="toc-number">2.4.2.</span> <span class="toc-text">try{…}catch{…}</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-number">2.5.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常"><span class="toc-number">2.6.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">3.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread"><span class="toc-number">3.1.</span> <span class="toc-text">Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread和Runnable的区别"><span class="toc-number">3.2.</span> <span class="toc-text">Thread和Runnable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-number">3.3.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-number">3.4.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程六种状态"><span class="toc-number">3.5.</span> <span class="toc-text">线程六种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-number">3.6.</span> <span class="toc-text">线程池</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">不蒸馒头争口气</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java-异常、线程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-15 17:17:27"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-22 21:30:42"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-22</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">8.4k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 30 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Debug调试程序"><a href="#Debug调试程序" class="headerlink" title="Debug调试程序"></a>Debug调试程序</h2><ul>
<li>可以让代码逐行执行,查看代码执行的过程,调试程序出现的Debug</li>
<li>使用方式<ul>
<li>可以在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug,添加到哪里)</li>
<li>右键选择debug执行程序,程序就学会停留在添加的第一个断点处</li>
</ul>
</li>
<li>执行程序<ul>
<li>F8: 逐行执行程序</li>
<li>F7: 进入到方法中</li>
<li>shift+F8  跳出方法</li>
<li>F9 : 跳到下一个断点,如果没有下一个断电,那么就结束程序</li>
<li>ctrl+F2 : 退出debug模式,停止程序</li>
</ul>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" alt="异常体系"></p>
<ul>
<li><p>Throwable 类是所有错误或异常的超类</p>
<ul>
<li>Exception:编译器异常 ,进行编译(写代码),Java程序出现的问题<ul>
<li>RuntimeException :运行期异常,Java程序运行过程中出现的问题</li>
</ul>
</li>
<li>Error: 错误,系统内部的错误,必须修改代码,程序才能继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常的处理过程: jvm检测到异常,会做两件事</p>
<ol>
<li>JVM会根据异常产生的原因,创建一个异常对象,这个异常对象包含了异常产生的内容、原因、位置    例:数组中索引最大为2,却要访问3,会有数组越界异常   new ArrayIndexOutIfBoundsException(“3”)</li>
<li>在所调用的方法中没有异常的处理逻辑,JVM就会把异常抛出给异常的调用者main方法,来处理这个异常,main接收到这个异常对象,但main方法也没有处理措施,main继续把对象抛出给main方法的调用者JVM处理,JVM接受到这个异常,又会做两件事<pre><code>1. 把异常对象(内容、原因、位置)以红色的字体打印在控制台
    2. JVM会终止当前正在执行的java程序--&gt;中断处理</code></pre></li>
</ol>
</li>
</ul>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><ul>
<li><p>可以使用throw关键字在指定的方法中抛出指定的异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用格式</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> xxxException(<span class="string">"异常产生的原因"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意:</p>
<ul>
<li>throw关键字必须写在方法的内部</li>
<li>throw关键字后边的new的对象必须是Exception或者是Exception的子类对象</li>
<li>throw关键字抛出指定的异常对象,我们就必须处理这个异常对象<ul>
<li>throw关键字后面创建的是RuntimeException或者是RuntimeException 的子类对象,我们可以不处理,默认交给JVM处理(打印异常,中断程序)</li>
<li>throw关键字后面创建的是编译异常(写代码时报错),我们就必须处理这个异常,要么throws要么try…catch…</li>
</ul>
</li>
</ul>
</li>
<li><p>实际中方法接收参数后必须对方法进行合法性检测,若不合法,需抛出异常,告知使用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们需对传递过来的参数数组进行合法性校验</span></span><br><span class="line"><span class="comment">    如果arr的值是null,那么就需要抛出空指针异常,告知方法的调用者,传递的数组值是null</span></span><br><span class="line"><span class="comment">    空指针异常是一个运行期异常,默认交给JVM处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>)&#123;<span class="comment">//如果arr的值是null,抛出空指针异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"传递的数组值为null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果index不在数组索引范围内,则抛出索引越界异常,告知方法调用者,传递的索引有误</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; arr.length()-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutIfBoundsException(<span class="string">"索引越界了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Objecs非空判断"><a href="#Objecs非空判断" class="headerlink" title="Objecs非空判断"></a>Objecs非空判断</h3><ul>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/15/1/Objects%E9%9D%9E%E7%A9%BA%E5%88%A4%E6%96%AD.png" alt="Objects非空判断"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对传递过来的参数进行合法性判断,判断是否为null</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(obj == null)&#123;</span></span><br><span class="line"><span class="comment">        throw new NullPointerException("传递的对象值为null");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//使用Objects的requireNonNull静态方法,可简化上述代码</span></span><br><span class="line">    Objects.requireNull(obj);</span><br><span class="line">    <span class="comment">//重载的requireNonNull方法,可以输出提示语</span></span><br><span class="line">    Objects.requireNull(obj,<span class="string">"传递的对象值为null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*throws关键字: 异常处理的第一种方式,交给别人处理</span></span><br><span class="line"><span class="comment">*使用格式:在方法声明时使用</span></span><br><span class="line"><span class="comment">* 修饰符 返回值类型 方法名(参数列表) throws AAAException, throw new BBBException&#123;</span></span><br><span class="line"><span class="comment">*     throw new AAAException("产生原因");</span></span><br><span class="line"><span class="comment">*     throw new BBBException("产生原因");</span></span><br><span class="line"><span class="comment">*     ...</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">* 注意:</span></span><br><span class="line"><span class="comment">*   1. throws关键字必须写在方法的声明出</span></span><br><span class="line"><span class="comment">*   2. throws关键字后边声明的异常必须是Exception或者是Exception的子类</span></span><br><span class="line"><span class="comment">*   3. 方法内部如果抛出了多个异常对象,那么throws后边必须也声明多个异常</span></span><br><span class="line"><span class="comment">*       如果抛出的多个异常对象又子父类关系,那么直接声明父类即可</span></span><br><span class="line"><span class="comment">*   4.调用了一个声明抛出异常的方法,就必须声明处理的异常,要么继续使用throws</span></span><br><span class="line"><span class="comment">*       声明抛出,交给方法的调用者处理,最终交给JVM.要么try...catch...</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThrows</span> </span>&#123;</span><br><span class="line">    <span class="comment">//FileNotFoundException extends IOException 可不声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//此处继续抛出,交给JVM处理</span></span><br><span class="line">        readFile(<span class="string">"C:\\a.txt"</span>);<span class="comment">//会有编译异常,必须处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义方法判断文件路径的合法性,若不是C:\\a.txt抛出文件未发现异常,不是.txt结尾抛出io异常</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static void readFile(String filename) throws FileNotFoundException,IOException &#123;</span></span><br><span class="line">    <span class="comment">//public static void readFile(String filename) throws IOException &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!filename.equals(<span class="string">"C:\\a.txt"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"传递文件类型错误"</span>);<span class="comment">//此处为编译异常,必须处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!filename.endsWith(<span class="string">".txt"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件后缀出错"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"路径正确"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="try-…-catch-…"><a href="#try-…-catch-…" class="headerlink" title="try{…}catch{…}"></a>try{…}catch{…}</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * try...catch... : 自己处理异常</span></span><br><span class="line"><span class="comment">   * 格式:</span></span><br><span class="line"><span class="comment">   *   try&#123;</span></span><br><span class="line"><span class="comment">   *       可能出现异常的代码</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   *   catch(定义异常异常变量,用来接收try的异常对象)&#123;</span></span><br><span class="line"><span class="comment">   *       异常的处理逻辑,有异常对象之后,怎么处理异常</span></span><br><span class="line"><span class="comment">   *       一般会把异常信息记录到一个日志中</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   *   ...此处可包含多个catch</span></span><br><span class="line"><span class="comment">   *   catch(定义异常异常变量,用来接收try的异常对象)&#123;&#125;</span></span><br><span class="line"><span class="comment">   *   finally&#123;</span></span><br><span class="line"><span class="comment">   *     无论是否出现异常都会执行</span></span><br><span class="line"><span class="comment">   *     finally不能单独使用,必须与try一起使用,</span></span><br><span class="line"><span class="comment">   *     一般用于资源释放</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   *   执行完try..catch..后会继续执行之后的代码</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//测试输入的文件名是否符合要求</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTryCatch</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              readFile(<span class="string">"C:\\a.tx"</span>);</span><br><span class="line">          <span class="comment">//try抛出什么异常,catch定义什么异常对象,用来接收异常</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              <span class="comment">//System.out.println("文件后缀出错");</span></span><br><span class="line">          <span class="comment">/* ThrowAble类 定义了三个方法</span></span><br><span class="line"><span class="comment">              String getMessage()   返回此 throwable 的简短描述。</span></span><br><span class="line"><span class="comment">              String toString()   返回此 throwable 的详细消息字符串。</span></span><br><span class="line"><span class="comment">              void printStackTrace()   JVM打印异常默认调用此方法,异常信息最全面</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">              System.out.println(e.getMessage());</span><br><span class="line">              System.out.println(e.toString());</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">//"无论是否出现异常都会执行"</span></span><br><span class="line">              System.out.println(<span class="string">"资源释放"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">"后续代码"</span>);<span class="comment">//有try..catch..此处不会中断,会执行</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">	<span class="comment">//文件名合法性检测函数,若不符合要求,抛出异常</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!filename.endsWith(<span class="string">".txt"</span>)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件后缀出错"</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">"路径正确"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>多个异常的捕获</p>
<ul>
<li><p>多个异常分别处理</p>
</li>
<li><p>多个异常一次捕获,多次处理(通常使用)</p>
</li>
<li><p>注意事项: catch里边定义的异常变量,如果有子父类关系,那么子类的异常catch必须定义在上面,否则就会报错</p>
<ul>
<li><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E5%A4%9A%E6%AC%A1%E5%A4%84%E7%90%86try_catch.png" alt="多次处理try_catch"></li>
</ul>
</li>
<li><p>多个异常一次捕获,一次处理</p>
</li>
<li><p>运行时异常,可以既不捕获,也不声明</p>
</li>
</ul>
</li>
<li><p>如果finally有return语句,将会永远返回finally的结果,应当避免finally中写return</p>
</li>
<li><p>父类异常是什么样,子类方法就什么样</p>
<ul>
<li>如果父类出现了多个异常,子类重写父类方法时,可抛出和父类相同的异常或者是父类异常的子类,或者不抛出异常</li>
<li>若父类方法没有抛出异常,子类重写父类该方法时也不能抛出异常,此时子类产生该异常,只能捕获处理,不能声明抛出</li>
</ul>
</li>
<li><p>在try/catch后可以追加finally代码块,其中的代码就一定会执行,通常用于资源回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 父类异常是什么样,子类方法就什么样</span></span><br><span class="line"><span class="comment">    - 如果父类出现了多个异常,子类重写父类方法时,可抛出和父类相同的异常或者是父类异常的子类,或者不抛出异常</span></span><br><span class="line"><span class="comment">    - 若父类方法没有抛出异常,子类重写父类该方法时也不能抛出异常,此时子类产生该异常,只能捕获处理,不能声明抛出*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="comment">//子类重写父类方法时,可抛出和父类相同的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123; &#125;</span><br><span class="line">    <span class="comment">//子类重写父类方法时,可抛出父类异常的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException </span>&#123; &#125;</span><br><span class="line">    <span class="comment">//子类重写父类方法时,可不抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">//父类方法没有抛出异常,子类重写父类该方法时也不能抛出异常,只能捕获异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> <span class="comment">/*throws Exception 不允许,只能处理异常*/</span> </span>&#123;</span><br><span class="line">        <span class="comment">//throw new Exception();//报错</span></span><br><span class="line">        <span class="comment">//只能try/catch</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"编译器异常"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//在此处处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Java提供的异常不够我们使用时,需要自定义异常类</span></span><br><span class="line"><span class="comment"> * 格式:</span></span><br><span class="line"><span class="comment"> *   public class XXXException extends Exception / RuntimeException&#123;  &#125;</span></span><br><span class="line"><span class="comment"> *   需要添加一个空参构造方法,一个带异常信息的构造方法</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> *   1.自定义异常类一把都是以Exception结尾,说明该类是一个异常类</span></span><br><span class="line"><span class="comment"> *   2.自定义异常类,必须继承:</span></span><br><span class="line"><span class="comment"> *       Exception(编译器异常),如果方法内部抛出异常,必须throws或try/catch</span></span><br><span class="line"><span class="comment"> *       或者RuntimeException(运行期异常),那么自定义异常无需处理,交给JVM处理</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个空参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个带异常信息的构造方法</span></span><br><span class="line">    <span class="comment">//查看源码发现,所有的异常类的构造方法都会调用父类,让父类来处理异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%BB%83%E4%B9%A0.png" alt="自定义异常练习"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用户存在抛出异常</span></span><br><span class="line"><span class="comment"> * 分析:</span></span><br><span class="line"><span class="comment"> *   1.使用数组保存已经注册的用户名</span></span><br><span class="line"><span class="comment"> *   2.使用Scanner让用户输入注册的用户名</span></span><br><span class="line"><span class="comment"> *   3.定义一个方法对用户输入注册的用户,进行判断是否重复</span></span><br><span class="line"><span class="comment"> *       变量用户名数组,比较用户是否存在.</span></span><br><span class="line"><span class="comment"> *           若存在抛出RegisterException,告知用户用户名已被注册</span></span><br><span class="line"><span class="comment"> *           若不存在继续遍历比较,提示用户,注册成功</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegisterException</span> </span>&#123;</span><br><span class="line">    String[] usernames = &#123;<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入用户名"</span>);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkUsername(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RegisterException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//用户名合法性自定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkUsername</span><span class="params">(String name)</span> <span class="keyword">throws</span> RegisterException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String username : usernames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(username)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">"该用户已被注册"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"恭喜注册成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>并发与并行</p>
<ul>
<li>并发:指两个或多个事件在同一时间段内完成</li>
<li>并行:指两个或多个事件在同一时刻发生(同时发生)</li>
<li><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C.png" alt="并发并行"></li>
</ul>
</li>
<li><p>线程与进程</p>
<ul>
<li>进程: 一个内存中运行的应用程序,画图,qq,浏览器</li>
<li>线程: 是进程的一个执行单元,一个进程中可以有多个线程,多线程间互不影响</li>
<li>主线程:执行main方法的程序</li>
</ul>
</li>
</ul>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul>
<li><p>创建新执行线程有两种方法。一种方法是将类声明为 <code>Thread</code> 的子类。该子类应重写 <code>Thread</code> 类的  <code>run</code> 方法。</p>
</li>
<li><p>创建线程的另一种方法是声明实现 <code>Runnable</code> 接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建多线程的第一种方式 创建Thread的子类</span></span><br><span class="line"><span class="comment">* 实现步骤:</span></span><br><span class="line"><span class="comment">*   1.创建Thread类的子类</span></span><br><span class="line"><span class="comment">*   2.在Thread类的子类中重写子类中的方法,设置线程任务(做什么)</span></span><br><span class="line"><span class="comment">*   3.创建Thread类的子类对象</span></span><br><span class="line"><span class="comment">*   4.调用Thread类中的start()方法,开启新的线程,JVM调用该线程的run方法</span></span><br><span class="line"><span class="comment">* 结果是两个线程并发地运行；当前线程（从调用返回给 start 方法）和另一个线程（执行其 run 方法）。</span></span><br><span class="line"><span class="comment">* 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</span></span><br><span class="line"><span class="comment">* Java程序属于抢占式调度,优先级高先执行</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 获取线程的名称</span></span><br><span class="line"><span class="comment">*   1.使用Thread类中的getName()返回线程名称</span></span><br><span class="line"><span class="comment">*        String getName()  返回该线程的名称。</span></span><br><span class="line"><span class="comment">*   2.可以先获取到当前正在执行的线程,使用线程中的方法getName()返回线程名称</span></span><br><span class="line"><span class="comment">*        static Thread currentThread() 返回对当前正在执行的线程对象的引用。</span></span><br><span class="line"><span class="comment">*   主线名:  main</span></span><br><span class="line"><span class="comment">*   新线程名:Thread-0 Thread-1...</span></span><br><span class="line"><span class="comment">* 设置线程的名称</span></span><br><span class="line"><span class="comment">*    1.void setName(String name) 改变线程名称，使之与参数 name 相同。</span></span><br><span class="line"><span class="comment">*    2.创建一个带参数的构造方法,参数传递线程名称,super()父类的构造方法,</span></span><br><span class="line"><span class="comment">*      把线程名称传递给父类,让Thread给子线程起名字</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">////第二种方式设置线程名,传入线程名,可传参修改线程名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, String name1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.name = name1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main中使用:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread p1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    p1.start();<span class="comment">//会去调用run方法,与后续的循环并行执行</span></span><br><span class="line">    <span class="comment">//第一种方式设置线程名</span></span><br><span class="line">    p1.setName(<span class="string">"小强"</span>);</span><br><span class="line">    <span class="comment">//第一种方式获取当前线程的名称</span></span><br><span class="line">    String name = p1.getName();</span><br><span class="line">    <span class="comment">//会暂停一秒,再打印输出</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(name);<span class="comment">//thread-0</span></span><br><span class="line">    <span class="comment">//第二种获取当前线程的名称,此处为main主线程名称</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    System.out.println(t.getName());</span><br><span class="line">    <span class="comment">//第二种方式设置线程名</span></span><br><span class="line">    MyThread p2 = <span class="keyword">new</span> MyThread(<span class="string">"新线程名"</span>,<span class="string">"小强"</span>);</span><br><span class="line">    <span class="comment">//后续的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"main"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>Thread的方法</p>
<ul>
<li>String getName()   返回该线程的名称。</li>
<li>void start()   使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 </li>
<li>void run()  线程要执行的任务在此处定义</li>
<li>static void sleep(long millis) 使当前正在执行的线程以指定的毫秒数暂停,有异常</li>
<li>static Thread  currentThread() 返回对当前正在执行的线程对象的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建多线程的第二种方式,实现Runnable接口</span></span><br><span class="line"><span class="comment">*   Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法</span></span><br><span class="line"><span class="comment">*   Thread的构造方法可以传递Runnable的实现类对象</span></span><br><span class="line"><span class="comment">* 实现步骤:</span></span><br><span class="line"><span class="comment">*   1.创建Runnable接口的实现类</span></span><br><span class="line"><span class="comment">*   2.在实现类中重写Runnable接口的run方法,设置线程任务</span></span><br><span class="line"><span class="comment">*   3.创建Runnable实现类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line"><span class="comment">*   4.创建Thread类对象,构造方法中传递Runnable接口的实现类</span></span><br><span class="line"><span class="comment">*   5.调用Thread类中的start()方法,开启新线程的run()方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">//创建Runnable接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main中使用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Runnable实现类对象</span></span><br><span class="line">    PrimeRun primeRun = <span class="keyword">new</span> PrimeRun();</span><br><span class="line">    <span class="comment">//创建Thread类对象,构造方法中传递Runnable接口的实现类</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(primeRun);</span><br><span class="line">    <span class="comment">//调用Thread类中的start()方法,开启多线程</span></span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h3><ul>
<li><p>其实就是实现Runnable接口创建多线程程序的好处</p>
<ul>
<li><p>避免了单继承的局限性,  一个类只能继承一个类,类继承了Thread类就不能继承其他的类,实现了Runnable接口,还可以继承其他的类,实现其他的接口</p>
</li>
<li><p>增强了程序的扩展性,降低了程序的耦合性(解耦),实现了Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦),实现类中,重写了run()方法,用来设置线程任务,创建Thread类对象,调用start()方法,设置线程任务</p>
</li>
<li><p>使用过程中尽量使用Runnable接口</p>
</li>
<li><p>匿名内部类实现线程的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*匿名内部类实现线程的创建</span></span><br><span class="line"><span class="comment"> * 匿名: 没有名字</span></span><br><span class="line"><span class="comment"> * 内部类: 写在其他类内部的类</span></span><br><span class="line"><span class="comment"> * 匿名内部类: 简化代码</span></span><br><span class="line"><span class="comment"> * 格式:</span></span><br><span class="line"><span class="comment"> *     new 父类/接口()&#123;</span></span><br><span class="line"><span class="comment"> *        重写父类/接口中的方法</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new MyThread.start();</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程的接口Runnable</span></span><br><span class="line">    Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"程序员"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简易写法</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"农学人"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul>
<li><p>概述</p>
</li>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0.png" alt="线程安全概述"></p>
</li>
<li><p>实现买票</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置买票任务</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断票是否存在</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">              ticket--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main中使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建三个线程,同时开启,对共享的票出售</span></span><br><span class="line">  <span class="comment">//创建Runnable即接口的实现类对象</span></span><br><span class="line">  RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">  <span class="comment">//创建Thread类对象,构造方法中传递Runnable接口实现类对象</span></span><br><span class="line">  Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">  Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">  Thread t3 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">  <span class="comment">//调用start开启多线程</span></span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t3.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程安全是不允许产生的,我们可以让一个线程访问共享数据的时候,无论是否失去了CPU的执行权,让其他线程只能等待,等待当前线程买完票,其他线程再进行买票,保证始终一个线程在买票,此时就需要线程同步</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li>同步代码块</li>
<li>同步方法</li>
<li>锁机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">同步代码块格式:</span><br><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">  需要同步的代码块或者访问了共享数据的代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 解决线程安全的第一种方法:使用同步代码块</span></span><br><span class="line"><span class="comment">* 买票案例出现了线程安全问题</span></span><br><span class="line"><span class="comment">* 卖出了不存在的票和重复的票</span></span><br><span class="line"><span class="comment">* 注意:</span></span><br><span class="line"><span class="comment">*   1.同步代码块中的锁对象可以是任意的对象</span></span><br><span class="line"><span class="comment">*   2.但是必须保证多个线程使用的锁对象是同一个</span></span><br><span class="line"><span class="comment">*   3.锁对象作用:</span></span><br><span class="line"><span class="comment">*       把同步代码块锁住,只让一个线程在同步代码块中</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一共的票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置买票任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断票是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>同步技术的原理:</p>
<ul>
<li>使用了一个锁对象,这个锁对象叫同步锁,也叫对象监视器,  三个线程一起抢夺CPU的执行权,谁抢到了谁执行run()方法进行买票,t0抢到了CPU的执行权,执行run()方法,遇到synchronized代码块,这时t0会检查synchronized代码块 <font color="red"> 是否有锁对象,发现有,就会获取到锁对象,进入到同步执行, </font>   t1抢到了cpu的执行权,执行run()方法,遇到synchronized代码块,这时t1也会检查synchronized代码块是否有锁对象,<font color="red"> 发现没有,t1就会进入到阻塞状态,一直等待t0线程归还锁对象,</font>一直到t0线程执行完同步中的同步代码,t0就会把锁对象归还给同步代码块,这时候,t1才能获取到锁对象,进入同步代码块执行</li>
<li>一句话: 同步中的线程没有执行完毕,不会释放锁.    同步外的线程,没有锁,不会进入线程</li>
<li>同步保证了只能有一个线程在同步中执行共享数据,保证了安全,但是,频繁的判断锁,获取锁,释放锁,程序的效率就会有所降低</li>
</ul>
</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">同步方法格式:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  可能会产生线程安全的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个锁对象</span></span><br><span class="line">  Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 解决线程安全的第二种方法:使用同步方法</span></span><br><span class="line"><span class="comment">  * 使用步骤:</span></span><br><span class="line"><span class="comment">  *   1.把访问了共享数据的代码块抽取出来,放到一个方法中</span></span><br><span class="line"><span class="comment">  *   2.在方法上添加一个synchronized修饰符</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">  <span class="comment">//定义同步方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//放需要同步的代码</span></span><br><span class="line">          <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">              ticket--;</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置买票任务</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断票是否存在</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="comment">//调用同步方法</span></span><br><span class="line">          method();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步方法也会把方法内部的代码锁住,只让一个线程执行,同步方法的锁对象其实就是实现类对象,也就是this</p>
</li>
<li><p>也可将同步方法设为静态同步方法,同样能够保证安全,静态同步方法的锁对象不能是this,this是创建对象产生的,而静态方法的创建优先于对象,静态同步方法的锁对象是本类的class属性–&gt;class文件对象   synchronized(RunnableImpl.class)</p>
</li>
</ul>
<ul>
<li><p>Lock锁方法</p>
</li>
<li><p>(java.util.concurrent.locks)包,是一个接口需要用它的实现类ReentrantLock</p>
</li>
<li><p><code>Lock</code> 实现提供了比使用 <code>synchronized</code> 方法和语句可获得的更广泛的锁定操作。</p>
</li>
<li><p>方法</p>
</li>
<li><p>void lock() 获取锁</p>
</li>
<li><p>void unlock 释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 解决线程安全的第三种方法:使用Lock锁</span></span><br><span class="line"><span class="comment">   * 使用步骤:</span></span><br><span class="line"><span class="comment">   *   1.在成员位置创建一个ReentrantLock对象</span></span><br><span class="line"><span class="comment">   *   2.在可能出现安全问题的代码前调用Lock接口中的方法lock()获取锁</span></span><br><span class="line"><span class="comment">   *   3.在可能出现安全问题的代码后调用Lock接口中的方法unlock获取锁</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="comment">//在成员位置创建一个ReentrantLock对象</span></span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置买票任务</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="comment">//调用前获取锁</span></span><br><span class="line">          lock.lock();</span><br><span class="line">          <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖第"</span> + ticket + <span class="string">"张票"</span>);</span><br><span class="line">                  ticket--;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">//将释放锁放到finally中,无论程序是否异常,都释放锁</span></span><br><span class="line">                  <span class="comment">//可以提供程序效率</span></span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="线程六种状态"><a href="#线程六种状态" class="headerlink" title="线程六种状态"></a>线程六种状态</h3><ul>
<li><p>NEW   至今尚未启动的线程处于这种状态。 </p>
</li>
<li><p>RUNNABLE   正在 Java 虚拟机中执行的线程处于这种状态。 </p>
</li>
<li><p>BLOCKED    受阻塞并等待某个监视器锁的线程处于这种状态。 </p>
</li>
<li><p>WAITING    无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。</p>
</li>
<li><p>TIMED_WAITING 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。 </p>
</li>
<li><p>TERMINATED    已退出的线程处于这种状态。</p>
</li>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p>
</li>
<li><p>等待唤醒案例:线程之间的通信</p>
</li>
<li><p>多个线程在处理同一个资源,但是处理的动作(线程的任务)却不同</p>
</li>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%A1%88%E4%BE%8B.png" alt="等待唤醒案例"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建一个消费者线程,告知生产者所需资源种类与数量,调用wait()方法,进入无限等待状态</span></span><br><span class="line"><span class="comment">* 创建一个生成者线程,花了5秒生成资源,生成之后,调用notify()方法,唤醒消费者</span></span><br><span class="line"><span class="comment">* 注意:</span></span><br><span class="line"><span class="comment">*   1.生产者和消费者必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行</span></span><br><span class="line"><span class="comment">*   2.同步使用的锁对象必须唯一</span></span><br><span class="line"><span class="comment">*   3.只有锁对象才能调用wait()和notify()方法</span></span><br><span class="line"><span class="comment">*   Object中的方法</span></span><br><span class="line"><span class="comment">*       void wait()</span></span><br><span class="line"><span class="comment">*         在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。进入wait set中,不会浪费CPU资源,线程状态时WAITING</span></span><br><span class="line"><span class="comment">*       void notify()</span></span><br><span class="line"><span class="comment">*         唤醒在此对象监视器上等待的单个线程。 唤醒之后会继续执行wait之后的代码,线程后被唤醒,继续检测锁的状态,如果能获取到锁,就进入就绪态,如果获取不到,变为阻塞状态</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 进入TimeWaiting(计时等待)两种方式</span></span><br><span class="line"><span class="comment">* 1.使用sleep(long m)方法,在线程睡醒后进入Runnable或Block</span></span><br><span class="line"><span class="comment">* 2.使用wait(long m)方法,如果在毫秒值结束后还未被notify(),就会自动醒来</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 唤醒的方法:</span></span><br><span class="line"><span class="comment">* 1.notify()唤醒单个线程</span></span><br><span class="line"><span class="comment">* 2.notify()All唤醒所有线程</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建锁对象,保证唯一</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//创建消费者1进程</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//保证等待和唤醒只能有一个执行,使用同步技术</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费者1告知生产者资源种类和数量"</span>);</span><br><span class="line">                <span class="comment">//用锁对象调用wait方法进入无限等待状态</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait(<span class="number">5000</span>);<span class="comment">//5秒后还未被notify(),就会自动醒来.</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//唤醒之后执行的代码</span></span><br><span class="line">                System.out.println(<span class="string">"消费者1唤醒之后执行的代码"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建消费者2进程</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//保证等待和唤醒只能有一个执行,使用同步技术</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费者2告知生产者资源种类和数量"</span>);</span><br><span class="line">                <span class="comment">//用锁对象调用wait方法进入无限等待状态</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//唤醒之后执行的代码</span></span><br><span class="line">                System.out.println(<span class="string">"消费者2唤醒之后执行的代码"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建生产者进程</span></span><br><span class="line">    <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//生产者花五秒钟生成资源,睡眠5秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);<span class="comment">//花五秒钟生成资源,</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保证等待和唤醒只能有一个执行,使用同步技术</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(<span class="string">"5秒之后生成资源,告知消费者"</span>);</span><br><span class="line">                <span class="comment">//obj.notify();//唤醒单个进程</span></span><br><span class="line">                obj.notify();<span class="comment">//两个消费者进程都唤醒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>等待唤醒类(生产者消费者类)实现</p>
</li>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E7%B1%BB%E5%AE%9E%E7%8E%B0.png" alt="等待唤醒类实现"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 包子类</span></span><br><span class="line"><span class="comment"> * 属性: 皮  馅</span></span><br><span class="line"><span class="comment"> * 包子状态: 有 true  没有false</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    String pi;</span><br><span class="line">    String xian;</span><br><span class="line">    Boolean flage = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 生产者(包子铺)类: 是一个线程类,可以继承Thread</span></span><br><span class="line"><span class="comment"> * 设置线程任务(run):生产包子</span></span><br><span class="line"><span class="comment"> * 对包子状态进行判断:</span></span><br><span class="line"><span class="comment"> *   true: 有包子</span></span><br><span class="line"><span class="comment"> *       包子铺调用wait()方法等待顾客</span></span><br><span class="line"><span class="comment"> *   false: 没包子</span></span><br><span class="line"><span class="comment"> *       包子铺交替生产两种包子(i%2==0)</span></span><br><span class="line"><span class="comment"> *       包子铺生产好包子,修改包子状态为true</span></span><br><span class="line"><span class="comment"> *       唤醒吃货线程</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> *   包子铺线程和吃货线程关系--&gt;通信(互斥)</span></span><br><span class="line"><span class="comment"> *   必须使用同步技术保证两个线程只有一个在执行</span></span><br><span class="line"><span class="comment"> *   锁对象必须保证唯一,可以使用包子作为锁对象</span></span><br><span class="line"><span class="comment"> *   包子铺类和吃货类需要把包子对象作为参数使用</span></span><br><span class="line"><span class="comment"> *       1.在成员位置创建一个包子变量</span></span><br><span class="line"><span class="comment"> *       2.使用带参构造方法,为包子赋值</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在成员位置创建一个包子变量</span></span><br><span class="line">    <span class="keyword">private</span> BaoZi baoZi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用带参构造方法,为包子赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(BaoZi baoZi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baoZi = baoZi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用同步技术保证两个线程只有一个在执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置一个变量记录生产何种包子</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//让包子铺一直生产包子</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//使用同步技术</span></span><br><span class="line">            <span class="keyword">synchronized</span> (baoZi) &#123;</span><br><span class="line">                <span class="comment">//如果有包子铺有包子则等待</span></span><br><span class="line">                <span class="keyword">if</span> (baoZi.flage == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baoZi.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若没有包子</span></span><br><span class="line">                <span class="comment">//被唤醒后执行,生产包子</span></span><br><span class="line">                <span class="comment">//交替生产两种包子(i%2==0)</span></span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//生产薄皮三鲜馅包子</span></span><br><span class="line">                    baoZi.pi = <span class="string">"薄皮"</span>;</span><br><span class="line">                    baoZi.xian = <span class="string">"三鲜馅"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//生产冰皮,牛肉大葱陷</span></span><br><span class="line">                    baoZi.pi = <span class="string">"冰皮"</span>;</span><br><span class="line">                    baoZi.xian = <span class="string">"牛肉大葱陷"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">"包子铺正在生产"</span> + baoZi.pi + baoZi.xian + <span class="string">"包子"</span>);</span><br><span class="line">                <span class="comment">//生产包子需要3秒</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//生产好包子,修改包子状态为true</span></span><br><span class="line">                baoZi.flage = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//唤醒吃货进程</span></span><br><span class="line">                baoZi.notify();</span><br><span class="line">                System.out.println(<span class="string">"包子生产好了"</span> + baoZi.pi + baoZi.xian + <span class="string">"包子,可以开吃了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 消费者(吃货)类:是一个线程类,可以继承Thread</span></span><br><span class="line"><span class="comment"> * 设置线程任务(run):吃包子</span></span><br><span class="line"><span class="comment"> * 对包子状态进行判断:</span></span><br><span class="line"><span class="comment"> *   true: 没包子</span></span><br><span class="line"><span class="comment"> *       包子铺调用wait()方法等待做包子</span></span><br><span class="line"><span class="comment"> *   false: 有包子</span></span><br><span class="line"><span class="comment"> *       吃包子,吃货吃完包子</span></span><br><span class="line"><span class="comment"> *       修改包子的状态为false没有</span></span><br><span class="line"><span class="comment"> *       唤醒包子铺线程,生产包子</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在成员位置创建一个包子变量</span></span><br><span class="line">    <span class="keyword">private</span> BaoZi baozi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用带参构造方法,为包子赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(BaoZi baoZi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baozi = baoZi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一直让吃货吃包子</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//使用同步技术</span></span><br><span class="line">            <span class="keyword">synchronized</span> (baozi) &#123;</span><br><span class="line">                <span class="comment">//若没有包子则等待</span></span><br><span class="line">                <span class="keyword">if</span> (baozi.flage == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baozi.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//包子好了</span></span><br><span class="line">                <span class="comment">//被唤醒之后</span></span><br><span class="line">                System.out.println(<span class="string">"正在吃包子,"</span> + baozi.pi + baozi.xian + <span class="string">",真香"</span>);</span><br><span class="line">                <span class="comment">//吃包子要两秒</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//吃完包子设置状态为没包子了</span></span><br><span class="line">                baozi.flage = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//唤醒包子铺线程</span></span><br><span class="line">                baozi.notify();</span><br><span class="line">                System.out.println(<span class="string">"吃完了,让包子铺开始生产"</span>);</span><br><span class="line">                System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 包含main方法启动程序</span></span><br><span class="line"><span class="comment"> * 创建包子对象</span></span><br><span class="line"><span class="comment"> * 创建包子铺线程,做包子</span></span><br><span class="line"><span class="comment"> * 创建吃货线程,吃包子</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaoZi baoZi = <span class="keyword">new</span> BaoZi();</span><br><span class="line">        <span class="keyword">new</span> BaoZiPu(baoZi).start();</span><br><span class="line">        <span class="keyword">new</span> ChiHuo(baoZi).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li><p>如果并发的线程数量很多,并且每个线程都是执行一个时间很短的任务就结束了,这种频繁创建线程就会影响系统的效率,因为频繁创建线程和销毁线程也需要时间. </p>
</li>
<li><p><strong>线程池:</strong> 其实就是一个容纳多个线程的容器,其中的线程可以反复使用,<strong>省去了频繁创建线程对象的操作,无需反复创建线程而消耗过多的资源</strong></p>
</li>
<li><p>线程容器–&gt;集合(ArrayList HashSet LinkedList&lt;Thread&gt; HashMap)    用LinkedList&lt;Thread&gt;最好</p>
</li>
<li><p>当程序第一次启动的时候,可以创建多个线程保存到集合中,  当要使用线程的时候,就可以从集合中取出线程来使用  </p>
<ul>
<li>使用<code>Thread t = list.remove(0);</code>返回被移除的第一个元素(线程只能被一个任务使用) </li>
<li>或<code>Thread t = linked.removeFirst();</code> 返回被移除的第一个元素</li>
<li>当使用完毕线程 ,需要把线程归还给线程池  <code>list.addd(0);</code>  或 <code>linked.addLast();</code></li>
<li>在jdk1.5之后jdk内置了线程池,可以直接使用,不用自己创建</li>
</ul>
</li>
<li><p><img src= "/img/loading.gif" data-src="/2020/07/15/1/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池"></p>
</li>
<li><p>好处:</p>
<ul>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可观理性</li>
</ul>
</li>
<li><p>线程池的使用 </p>
<ul>
<li><p>Executors 生产线程池的工厂类其中有一个静态方法返回一个线程池</p>
<ul>
<li><code>static ExecutorService newFixedThreadPool(int nThreads)</code>     创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。参数nThreads: 创建的线程池中的线程数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程池: jdk1.5之后</span></span><br><span class="line"><span class="comment"> * java.util.concurrent.Executors:  线程池的工厂类,用来生产线程池</span></span><br><span class="line"><span class="comment"> *   方法: static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> *       创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。</span></span><br><span class="line"><span class="comment"> *       参数:</span></span><br><span class="line"><span class="comment"> *           创建线程池中线程数</span></span><br><span class="line"><span class="comment"> *       返回值:</span></span><br><span class="line"><span class="comment"> *           ExecutorService接口类型,返回的ExecutorService的实现类对象,可以使ExecutorService来接收(面向接口编程)</span></span><br><span class="line"><span class="comment"> *java.util.concurrent.ExecutorService:线程池接口</span></span><br><span class="line"><span class="comment"> *   从线程池中获取线程,调用start方法,执行线程任务:</span></span><br><span class="line"><span class="comment"> *       Future&lt;?&gt; submit(Runnable task)  提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。    //返回值Future&lt;?&gt;可以不管</span></span><br><span class="line"><span class="comment"> *   关闭/销毁线程池的方法:</span></span><br><span class="line"><span class="comment"> *       void shutdown()  启动一次顺序关闭，执行以前提交的任务，但不接受新任务</span></span><br><span class="line"><span class="comment"> * 使用步骤:</span></span><br><span class="line"><span class="comment"> *   1.使用线程池的工厂类Executors里边的静态方法newFixedThreadPool生产一个指定数量的线程池</span></span><br><span class="line"><span class="comment"> *   2.创建一个类,实现Runnable接口,重写run方法,设置线程任务</span></span><br><span class="line"><span class="comment"> *   3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法</span></span><br><span class="line"><span class="comment"> *   4.调用ExecutorService中的方法shutdown销毁线程池(不建议执行)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Runnable接口,重写run方法,设置线程任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"创建了一个新线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main中使用线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程池的工厂类Executors里边的静态方法newFixedThreadPool生产一个有2个线程的线程池</span></span><br><span class="line">    ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//调用ExecutorService中的方法submit,传递线程任务(实现类),自动开启线程,执行run方法</span></span><br><span class="line">    es.submit(<span class="keyword">new</span> RunnableImpl());<span class="comment">//pool-1-thread-1创建了一个新线程</span></span><br><span class="line">    <span class="comment">//线程池会一直开启,使用完了线程,会自动把线程归还给线程池,线程可以继续使用</span></span><br><span class="line">    es.submit(<span class="keyword">new</span> RunnableImpl());<span class="comment">//pool-1-thread-1创建了一个新线程</span></span><br><span class="line">    es.submit(<span class="keyword">new</span> RunnableImpl());<span class="comment">//pool-1-thread-2创建了一个新线程</span></span><br><span class="line">    <span class="comment">//调用ExecutorService中的方法shutdown销毁线程池(不建议执行)</span></span><br><span class="line">    es.shutdown();</span><br><span class="line">    es.submit(<span class="keyword">new</span> RunnableImpl());<span class="comment">//出错,会有异常,线程池已销毁,不能获取线程了</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">laden</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lqhao.gitee.io/2020/07/15/1/">http://lqhao.gitee.io/2020/07/15/1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lqhao.gitee.io" target="_blank">不蒸馒头争口气</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Exception/">Exception</a><a class="post-meta__tags" href="/tags/Thread/">Thread</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/weixinpay.jpg" alt="微信" onclick="window.open('https://gitee.com/lqhao/img-bed/raw/master/img-page/weixinpay.jpg')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/alipay.jpg" alt="支付宝" onclick="window.open('https://gitee.com/lqhao/img-bed/raw/master/img-page/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/15/3/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java-Lambda表达式</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/13/1/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java-日期、System类、Collection集合</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/25/2/" title="Java-JDBC连接池、JDBCTemplate"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-25</div><div class="relatedPosts_title">Java-JDBC连接池、JDBCTemplate</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/08/1/" title="Java-API-说明文档推荐"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-08</div><div class="relatedPosts_title">Java-API-说明文档推荐</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/20/2/" title="Java-Stream流"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-20</div><div class="relatedPosts_title">Java-Stream流</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By laden</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>