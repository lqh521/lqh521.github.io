<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java-File、IO流 | 不蒸馒头争口气</title><meta name="description" content="File类java.io.File类是文件和目录路径名的抽象表示,主要用于文件和目录的创建、查找和删除等操作,File是一个与系统无关的类,任何的操作系统都可以使用类中的方法,  记住三个词:  file:文件  directory :文件夹&#x2F;目录   path :路径  静态变量  static String pathSeparator  与系统有关的路径分隔符，为了方便，它被表示为一个字符串。"><meta name="keywords" content="Java,FIle,IO"><meta name="author" content="laden"><meta name="copyright" content="laden"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lqhao.gitee.io/2020/07/18/1/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Java-File、IO流"><meta property="og:url" content="http://lqhao.gitee.io/2020/07/18/1/"><meta property="og:site_name" content="不蒸馒头争口气"><meta property="og:description" content="File类java.io.File类是文件和目录路径名的抽象表示,主要用于文件和目录的创建、查找和删除等操作,File是一个与系统无关的类,任何的操作系统都可以使用类中的方法,  记住三个词:  file:文件  directory :文件夹&#x2F;目录   path :路径  静态变量  static String pathSeparator  与系统有关的路径分隔符，为了方便，它被表示为一个字符串。"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-18T02:30:50.961Z"><meta property="article:modified_time" content="2020-07-22T13:24:01.709Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Java-网络编程" href="http://lqhao.gitee.io/2020/07/19/1/"><link rel="next" title="Java-Lambda表达式" href="http://lqhao.gitee.io/2020/07/15/3/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/04232036663275.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#File类"><span class="toc-number">1.</span> <span class="toc-text">File类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO流"><span class="toc-number">2.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字节流"><span class="toc-number">2.1.</span> <span class="toc-text">字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符流"><span class="toc-number">2.2.</span> <span class="toc-text">字符流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO异常的处理"><span class="toc-number">2.3.</span> <span class="toc-text">IO异常的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性集-Properties"><span class="toc-number">2.4.</span> <span class="toc-text">属性集  Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲流Buffer"><span class="toc-number">2.5.</span> <span class="toc-text">缓冲流Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换流-InputStreamReader-OutputStreamWriter"><span class="toc-number">2.6.</span> <span class="toc-text">转换流 InputStreamReader  OutputStreamWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化"><span class="toc-number">2.7.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打印流"><span class="toc-number">2.8.</span> <span class="toc-text">打印流</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">不蒸馒头争口气</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java-File、IO流</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-18 10:30:50"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-18</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-22 21:24:01"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-22</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">10.7k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 39 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>java.io.File类是文件和目录路径名的抽象表示,主要用于文件和目录的创建、查找和删除等操作,File是一个与系统无关的类,任何的操作系统都可以使用类中的方法,</p>
<ul>
<li><p>记住三个词:  file:文件  directory :文件夹/目录   path :路径</p>
</li>
<li><p>静态变量</p>
<ul>
<li>static String pathSeparator  与系统有关的路径分隔符，为了方便，它被表示为一个字符串。 <ul>
<li>windows  为”;”</li>
<li>Linux   为”:”</li>
</ul>
</li>
<li>static String separator    与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 文件名称分隔符 <ul>
<li>windows  为”\“</li>
<li>Linux  为”/“</li>
</ul>
</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>File(File parent, String child)    根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 </li>
<li>File(String pathname)      通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。 </li>
<li>File(String parent, String child)       根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。 </li>
<li>File(URI uri)       通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例。 </li>
</ul>
</li>
<li><p>常用的获取方法</p>
<ul>
<li>String getAbsolutePath(): 返回此File的绝对路径名字字符串</li>
<li>String getPath() : 返回此File转换为路径名字符串,toString()调用的就是这个方法</li>
<li>String getName(): 返回由此File表示的文件或目录的名称</li>
<li>long length() : 返回由此File表示的文件的长度,以字节为单位</li>
</ul>
</li>
<li><p>常用判断功能的方法</p>
<ul>
<li>boolean exists(): 此文件或目录是否存在</li>
<li>boolean isDirectory(): 此File表示的是否为目录</li>
<li>boolean isFile(): 此File表示的是否为文件</li>
</ul>
</li>
<li><p>常用创建删除功能的方法</p>
<ul>
<li>boolean createNewFile() : 当且仅当具有该名称的文件尚不存在时,创建一个新的空文件</li>
<li>boolean delete(): 删除由此File表示的文件或目录</li>
<li>boolean mkdir() : 创建由此File表示的目录</li>
<li>boolean mkdirs() : 创建由此File表示的目录,包括任何必需但不存在的父目录 ,船创建多级文件</li>
</ul>
</li>
<li><p>常用目录的遍历</p>
<ul>
<li>String[ ]  list(): 返回String数组,表示该File目录中的所有子文件或目录, 路径不存在或给出的不是路径会抛出异常</li>
<li>File[ ] listfiles(): 返回File数组, 表示该File目录中的所有的子文件或目录</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *File(String pathname)通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。</span></span><br><span class="line"><span class="comment"> *参数:</span></span><br><span class="line"><span class="comment"> *   String pathname:字符串的路径名称</span></span><br><span class="line"><span class="comment"> *   路径可以是以文件结尾,也可以是以文件夹结尾</span></span><br><span class="line"><span class="comment"> *   路径可以是相对路径,也可以是绝对路径</span></span><br><span class="line"><span class="comment"> *   路径可以是存在的,也可以是不存在的</span></span><br><span class="line"><span class="comment"> *   创建File对象只是把字符串路径封装,不考虑真假</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">"F:\\2020_7_JavaStudy\\stage_2\\a.txt"</span>);</span><br><span class="line">    System.out.println(file1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File(String parent, String child)</span></span><br><span class="line"><span class="comment"> *   根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *   String parent, String child</span></span><br><span class="line"><span class="comment"> *   把路径分成了两部分,父路径,子路径,</span></span><br><span class="line"><span class="comment"> *   好处:两个路径可以单独书写,使用灵活,两个路径都可以变化</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">(String parent, String child)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(parent, child);</span><br><span class="line">    System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File(File parent, String child)</span></span><br><span class="line"><span class="comment"> *       根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</span></span><br><span class="line"><span class="comment"> * 参数:File parent, String child</span></span><br><span class="line"><span class="comment"> *   父路径为file类型,可以使用file类的方法,对路径进行操作,再创建对象</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File parent = <span class="keyword">new</span> File(<span class="string">"F:\\"</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(parent, <span class="string">"hello.java"</span>);</span><br><span class="line">    System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- String getAbsolutePath(): 返回此File的绝对路径名字字符串</span></span><br><span class="line"><span class="comment">- String getPath() : 返回此File转换为路径名字符串</span></span><br><span class="line"><span class="comment">- String getName(): 返回由此File表示的文件或目录的名称</span></span><br><span class="line"><span class="comment">- long length() : 返回由此File表示的文件的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"绝对路径:"</span> + file.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"字符串路径:"</span> + file.getPath());</span><br><span class="line">        System.out.println(<span class="string">"获取结尾名称:"</span> + file.getName());</span><br><span class="line">        System.out.println(<span class="string">"获取文件大小:"</span> + file.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- boolean exists(): 此文件或目录是否存在</span></span><br><span class="line"><span class="comment">- boolean isDirectory(): 此File表示的是否为目录,目录不存在也返回false</span></span><br><span class="line"><span class="comment">- boolean isFile(): 此File表示的是否为文件,文件不存在也返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"F:\\2020_7_JavaStudy\\stage_2\\a.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"此目录是否存在:"</span>+file.exists());</span><br><span class="line">        System.out.println(<span class="string">"此File是否为目录"</span>+file.isDirectory());</span><br><span class="line">        System.out.println(<span class="string">"此File是否为文件"</span>+file.isFile());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- boolean createNewFile() :</span></span><br><span class="line"><span class="comment">	当且仅当具有该名称的文件尚不存在时,创建一个新的空文件,路径为构造方法给出</span></span><br><span class="line"><span class="comment">- boolean delete(): 删除由此File表示的文件或目录</span></span><br><span class="line"><span class="comment">- boolean mkdir():  创建由此File表示的目录</span></span><br><span class="line"><span class="comment">- boolean mkdirs(): 创建由此File表示的目录,包括任何必需但不存在的父目录 ,船创建多级文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">    <span class="comment">//创建a.txt</span></span><br><span class="line">    file.createNewFile();<span class="comment">//若目录不存在,会有空指针异常</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">"F:\\FileTest\\789"</span>);</span><br><span class="line">    <span class="comment">//创建单级文件夹</span></span><br><span class="line">    file1.mkdir();</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">"F:\\FileTest\\123\\456"</span>);</span><br><span class="line">    <span class="comment">//既可以创建单级文件夹,也创建多级文件夹</span></span><br><span class="line">    file2.mkdirs();</span><br><span class="line">    <span class="comment">//既可以构造方法中的删除文件也可以删除文件夹,直接从硬盘删除</span></span><br><span class="line">    file.delete();</span><br><span class="line">    file2.delete();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- String[ ]  list():</span></span><br><span class="line"><span class="comment">返回String数组,表示该File目录中的所有子文件或目录,路径不存在或给出的不是路径会抛出异常</span></span><br><span class="line"><span class="comment">- File[ ] listfiles(): 返回File数组, 表示该File目录中的所有的子文件或目录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"F:\\FileTest"</span>);</span><br><span class="line">    String[] list = file.list();</span><br><span class="line">    <span class="keyword">for</span> (String filename : list) &#123;</span><br><span class="line">        System.out.println(filename);</span><br><span class="line">    &#125;</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file1 : files) &#123;</span><br><span class="line">        System.out.println(file1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用递归遍历多级目录文件案例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"F:\\FileTest"</span>);</span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 定义一个方法: 参数传递File类型的目录</span></span><br><span class="line"><span class="comment">     * 方法中对目录进行遍历</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="comment">//遍历目录</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//输出目录文件或文件夹名称</span></span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="comment">//若为文件夹,继续递归遍历</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                getAllFile(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件搜索案例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历文件只有.java结尾的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recurison</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"F:\\FileTest"</span>);</span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 定义一个方法: 参数传递File类型的目录</span></span><br><span class="line"><span class="comment">     * 方法中对目录进行遍历</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="comment">//遍历目录</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//输出目录文件或文件夹名称,后缀转换为小写,忽略大小写</span></span><br><span class="line">            <span class="comment">//file.getName().endsWith(".java")</span></span><br><span class="line">            <span class="comment">//file.getPath().endsWith(".java")</span></span><br><span class="line">            <span class="keyword">if</span> (file.toString().toLowerCase().endsWith(<span class="string">".java"</span>)) &#123;</span><br><span class="line">                <span class="comment">//输出目录文件或文件夹名称</span></span><br><span class="line">                System.out.println(file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若为文件夹,继续递归遍历</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                getAllFile(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件过滤器优化文件搜索</p>
<ul>
<li><p>将listFiles()方法传入过滤器,即FileFilter接口的实现类对象,或者FilenameFilter接口的实现类对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 可以使用过滤器来实现指定类型文件的筛选</span></span><br><span class="line"><span class="comment"> * 在File类中有两个和ListFiles重载的方法,方法的参数传递的就是过滤器</span></span><br><span class="line"><span class="comment"> *   File[] listFiles()</span></span><br><span class="line"><span class="comment"> *       返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</span></span><br><span class="line"><span class="comment"> *    File[] listFiles(FileFilter filter)</span></span><br><span class="line"><span class="comment"> *       返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span><br><span class="line"><span class="comment"> *    File[] listFiles(FilenameFilter filter)</span></span><br><span class="line"><span class="comment"> *       返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span><br><span class="line"><span class="comment"> *java.io.FileFilter接口:用于抽象路径名(File)的过滤器,过滤文件</span></span><br><span class="line"><span class="comment"> *   抽象方法:用来过滤文件</span></span><br><span class="line"><span class="comment"> *    boolean accept(File pathname) 试指定抽象路径名是否应该包含在某个路径名列表中。</span></span><br><span class="line"><span class="comment"> *    参数 pathname: 使用ListFiles方法遍历目录得到的每一个文件对象</span></span><br><span class="line"><span class="comment"> *java.io.FilenameFilter接口:实现此接口的类实例可用于过滤器文件名。</span></span><br><span class="line"><span class="comment"> *   抽象方法:</span></span><br><span class="line"><span class="comment"> *     boolean accept(File dir, String name)  测试指定文件是否应该包含在某一文件列表中。</span></span><br><span class="line"><span class="comment"> *     参数 dir被遍历的目录</span></span><br><span class="line"><span class="comment"> *         name:使用listFiles方法遍历目录,获取的每一个文件/文件夹的名称</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> *   两个过滤器接口没有实现类,需要自己写实现类,重写过滤的方法accept(),在方法中自己定义规则</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestRecurison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"F:\\FileTest"</span>);</span><br><span class="line">        getAllFile(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 定义一个方法: 参数传递File类型的目录</span></span><br><span class="line"><span class="comment">     * 方法中对目录进行遍历</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFile</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      使用匿名内部类,设置过滤器</span></span><br><span class="line"><span class="comment">      此处也可使用Lambda表达式(pathname)-&gt;</span></span><br><span class="line"><span class="comment">                        return </span></span><br><span class="line"><span class="comment">                    (pathname.toString().toLowerCase().endsWith(".java")||pathname.isDirectory())</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//FileFilter的方式</span></span><br><span class="line">        <span class="comment">/*File[] files = dir.listFiles(new FileFilter()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean accept(File pathname) &#123;</span></span><br><span class="line"><span class="comment">            //若结尾为.java或者是文件夹则保留返回true    </span></span><br><span class="line"><span class="comment">                if (pathname.toString().toLowerCase().endsWith(".java")||pathname.isDirectory())&#123;</span></span><br><span class="line"><span class="comment">                    return true;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//FilenameFilter接口方式</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> File(dir, name).isDirectory() || name.toLowerCase().endsWith(<span class="string">".java"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//遍历目录</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//若为文件夹,继续递归遍历</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                getAllFile(file);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>字符输入/出流,  字节输入/出流, 出入的对象是内存和硬盘,内存是主体.出:内存-&gt;硬盘</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节流</td>
<td align="center">字节输入流 InputStream</td>
<td align="center">字节输出流  OuputStream</td>
</tr>
<tr>
<td align="center">字符流</td>
<td align="center">字符输入流  Reader</td>
<td align="center">字符输出流   Writer</td>
</tr>
</tbody></table>
<ul>
<li>一切皆为字节,字节流可以读写任意的文件</li>
</ul>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul>
<li><p>OuputStream字节输出流方法</p>
<ul>
<li><p>void close() </p>
<pre><code>关闭此输出流并释放与此流有关的所有系统资源。 </code></pre></li>
<li><p>void flush() </p>
<pre><code>刷新此输出流并强制写出所有缓冲的输出字节。 </code></pre></li>
<li><p>void write(byte[] b) </p>
<pre><code>将 b.length 个字节从指定的 byte 数组写入此输出流。 </code></pre></li>
<li><p>void write(byte[] b, int off, int len) </p>
<pre><code>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 </code></pre></li>
<li><p>abstract  void write(int b) </p>
<pre><code>将指定的字节写入此输出流。 </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OutputStream 此抽象类是表示输出字节流的所有类的超类</span></span><br><span class="line"><span class="comment"> * 他的子类: FileOutputStream</span></span><br><span class="line"><span class="comment"> *构造方法:</span></span><br><span class="line"><span class="comment"> *   FileOutputStream(File file)  创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</span></span><br><span class="line"><span class="comment"> *   FileOutputStream(String name)  创建一个向具有指定名称的文件中写入数据的输出文件流。</span></span><br><span class="line"><span class="comment"> *   FileOutputStream(String name, boolean append)   创建一个向具有指定 name 的文件中写入数据的输出文件流。</span></span><br><span class="line"><span class="comment"> *   FileOutputStream(File file, boolean append)   创建一个向指定 File 对象表示的文件中写入数据的文件输出流</span></span><br><span class="line"><span class="comment"> *      参数: file name: 写入数据的目的地</span></span><br><span class="line"><span class="comment"> *           append : 追加写  true:追加写 false:创建新文件,覆盖写</span></span><br><span class="line"><span class="comment"> *   作用:</span></span><br><span class="line"><span class="comment"> *       1.创建一个FileOutputStream对象</span></span><br><span class="line"><span class="comment"> *       2.会根据构造方法中传递的文件/文件路径,创建一个空的文件</span></span><br><span class="line"><span class="comment"> *       3.会把FileOutputStream对象指向创建好的文件</span></span><br><span class="line"><span class="comment"> * 写入数据的原理(内存-&gt;硬盘)</span></span><br><span class="line"><span class="comment"> *   java程序-&gt;JVM(java虚拟机)-OS(操作系统)-&gt;OS调用写数据的方法,把数据写入文件</span></span><br><span class="line"><span class="comment"> * 字节输出流的使用步骤:</span></span><br><span class="line"><span class="comment"> *   1.创建一个FileOutputStream对象,构造方法传入写入数据目的地</span></span><br><span class="line"><span class="comment"> *   2.调用FileOutputStream对象中的write,把数据写入导文件中</span></span><br><span class="line"><span class="comment"> *   3.释放资源(流会占用一定的内存,使用完毕要把内存清空,提高程序的效率)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个FileOutputStream对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//一次写一个字节调用write(),十进制整数转换为二进制整数</span></span><br><span class="line">        fos.write(<span class="number">97</span>);<span class="comment">//写入一个字节'a'</span></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos1 = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"F:\\FileTest\\a.txt"</span>));</span><br><span class="line">        <span class="comment">//一次写多字节调用write()</span></span><br><span class="line">        <span class="keyword">byte</span>[] a = &#123;-<span class="number">65</span>, -<span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>&#125;;</span><br><span class="line">        fos1.write(a);<span class="comment">//传入字节数组</span></span><br><span class="line">        <span class="comment">//把字节数组的一部分写入到文件中</span></span><br><span class="line">        fos1.write(a, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//写入字符串的方法,可以使用String类中的方法,将String转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">"你好"</span>.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        fos1.write(bytes);</span><br><span class="line">        fos1.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//追加写</span></span><br><span class="line">        FileOutputStream fos3 = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\a.txt"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//追加写</span></span><br><span class="line">        fos3.write(<span class="string">"你好"</span>.getBytes());</span><br><span class="line">        <span class="comment">//换行写</span></span><br><span class="line">        <span class="comment">/*换行符号</span></span><br><span class="line"><span class="comment">        *   windows: \r\n</span></span><br><span class="line"><span class="comment">        *   linux: /n</span></span><br><span class="line"><span class="comment">        *   mac: /r</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fos3.write(<span class="string">"你好"</span>.getBytes());</span><br><span class="line">            fos3.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        fos3.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>InputStream字节输入流</p>
<ul>
<li>void close() <pre><code>关闭此输入流并释放与该流关联的所有系统资源。 </code></pre></li>
<li>abstract  int read() <pre><code>从输入流中读取数据的下一个字节。 </code></pre></li>
<li>int read(byte[] b) <pre><code>从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 </code></pre></li>
<li>int read(byte[] b, int off, int len) <pre><code>将输入流中最多 len 个数据字节读入 byte 数组。 </code></pre></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InputStream字节输入流:定义了所有子类共性的方法</span></span><br><span class="line"><span class="comment"> * 使用实现类:FilterInputStream extends InputStream</span></span><br><span class="line"><span class="comment"> * 作用:把硬盘文件中的数据读取到内存中</span></span><br><span class="line"><span class="comment"> * 构造方法:</span></span><br><span class="line"><span class="comment"> *   FilterInputStream(String name)</span></span><br><span class="line"><span class="comment"> *   FilterInputStream(File file)</span></span><br><span class="line"><span class="comment"> *读取数据原理: (硬盘-&amp;gt;内存)</span></span><br><span class="line"><span class="comment"> *   java程序-&amp;gt;JVM-&amp;gt;OS-&amp;gt;OS调用读取数据的方法,读取文件</span></span><br><span class="line"><span class="comment"> * 使用步骤:</span></span><br><span class="line"><span class="comment"> *   1.创建FilterInputStream对象,构造方法中绑定要读取的数据源</span></span><br><span class="line"><span class="comment"> *   2.使用read()方法,读取文件</span></span><br><span class="line"><span class="comment"> *   3.释放资源</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demoInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(&amp;quot;F:\\FileTest\\a.txt&amp;quot;);</span><br><span class="line">        <span class="comment">//读取文件的一个字节并返回,若末尾返回-1</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);<span class="comment">//a</span></span><br><span class="line">        <span class="comment">//每读一次指针向后移动一位</span></span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)read);<span class="comment">//b</span></span><br><span class="line">        <span class="comment">//循环读</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//(len=fis.read())!=-1的巧妙使用</span></span><br><span class="line">        <span class="keyword">while</span>((len=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*一次读取多个字节</span></span><br><span class="line"><span class="comment">         *int read(byte[] b)</span></span><br><span class="line"><span class="comment">         *  从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line"><span class="comment">         *int read(byte[] b, int off, int len)</span></span><br><span class="line"><span class="comment">         *  将输入流中最多 len 个数据字节读入 byte 数组。</span></span><br><span class="line"><span class="comment">         *参数: b:缓冲作用,设定一个数组来接收每次读取到的值,数组的长度一班定义为1024的整数倍</span></span><br><span class="line"><span class="comment">         *返回值: int为每次读取到的有效字节个数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        FileInputStream fis1 = <span class="keyword">new</span> FileInputStream(&amp;quot;F:\\FileTest\\b.txt&amp;quot;);</span><br><span class="line">        <span class="comment">//设定一个数组来接收读取到的值</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//返回int为读取到的字节的个数</span></span><br><span class="line">        <span class="keyword">int</span> read1 = fis1.read(bytes,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">        <span class="comment">//String的构造方法,传入bytes数组,从0开始,到指定长度转换为字符串</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read1));</span><br><span class="line">        System.out.println(read1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件的复制</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个字节输入流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">    <span class="comment">//创建一个字节输出流</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\m.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环读出,读出的不是-1就一直读</span></span><br><span class="line">   <span class="comment">/* while ((len = fis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">        //写入</span></span><br><span class="line"><span class="comment">        fos.write(len);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//使用数组缓冲来一次读取多个字节,写入多个字节</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//每次读出指定数组大小的内容</span></span><br><span class="line">    <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//每次从0开始写入指定长度的字节数</span></span><br><span class="line">        fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先关闭写流再关闭写流,写完了,就一定读完了</span></span><br><span class="line">    fos.close();</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意:字节流读取到中文字符时,可能不会显示完整的字符,因为一个中文字符可能占用多个字节存储,所以Java提供了一些字符流,以字符为单位,专门处理文本文件</p>
<ul>
<li>GBK 2字节</li>
<li>UTF-8 3个字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul>
<li><p>字符输入流 Reader</p>
<ul>
<li><p>colse() 关闭并释放与此流相关的任何系统资源</p>
</li>
<li><p>int read() 从输入流读入一个字符,并返回</p>
</li>
<li><p>int read(char[] cbuf) 从输入流读取一些字符,并将它们存储到字符数组cbuf中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reader:字符输入流最顶层的父类,是一个抽象类</span></span><br><span class="line"><span class="comment"> * 需要使用他的子类:FileReader extends InputStreamReader extends Reader</span></span><br><span class="line"><span class="comment"> * 作用:把硬盘中的内容以字符的方式读取到内存中</span></span><br><span class="line"><span class="comment"> * FileReader(File file)   在给定从中读取数据的 File 的情况下创建一个新 FileReader。</span></span><br><span class="line"><span class="comment"> * FileReader(String fileName)   在给定从中读取数据的文件名的情况下创建一个新 FileReader</span></span><br><span class="line"><span class="comment"> *    参数:读取文件的数据源</span></span><br><span class="line"><span class="comment"> *    作用:创建一个FileReader对象,把该对象指向要读取的文件</span></span><br><span class="line"><span class="comment"> * 使用步骤:</span></span><br><span class="line"><span class="comment"> *   1.创建一个FileReader对象,构造方法中绑定读取的数据源</span></span><br><span class="line"><span class="comment"> *   2.使用FileReader中的方法读取文件</span></span><br><span class="line"><span class="comment"> *   3.关闭流</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//每次读取单个字符</span></span><br><span class="line">        <span class="comment">/*int read = 0;</span></span><br><span class="line"><span class="comment">        while ((read = fr.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">            System.out.print((char) read);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//每次读取一个数组</span></span><br><span class="line">        <span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];<span class="comment">//存储读取到的多个字符</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//存读每次读取的有效字符个数,若为-1读结束</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//String(char[] value, int offset, int count)</span></span><br><span class="line">            <span class="comment">//将字符数组转为字符串</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(cs, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符输入流 Writer</p>
<ul>
<li><p>write(int c) 写入单个字符</p>
</li>
<li><p>write(char[] cbuf) 写入字符数组</p>
</li>
<li><p>abstract void write(char[] bufer, int off, int len) 写入字符数组的某一部分,off为开始索引,len为写入的字符个数</p>
</li>
<li><p>write(String str) 写入字符串,将数据写入到内存缓存区当中(字符转换为字节的过程)</p>
</li>
<li><p>write(String str, int off, int len) 写入字符串的某一部分,off为开始索引,len为写入的字符个数</p>
</li>
<li><p>flush()  将内存缓冲区中的内容刷新到硬盘文件中,刷新缓冲区,流对象可以继续使用</p>
</li>
<li><p>close() 关闭流, 先刷新缓冲区,通知系统释放资源,流对象不可以再使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Writer抽象类:是所有字符输出流的父类</span></span><br><span class="line"><span class="comment"> * 所用的子类:FileWriter extends OutputStreamWriter extendsWriter</span></span><br><span class="line"><span class="comment"> * 作用:把内存中的字符数据写入到文件自</span></span><br><span class="line"><span class="comment"> * 构造方法:</span></span><br><span class="line"><span class="comment"> *   FileWriter(File file)</span></span><br><span class="line"><span class="comment"> *       根据给定的 File 对象构造一个 FileWriter 对象。</span></span><br><span class="line"><span class="comment"> *   FileWriter(String fileName)</span></span><br><span class="line"><span class="comment"> *       根据给定的文件名构造一个 FileWriter 对象。</span></span><br><span class="line"><span class="comment"> *   参数:文件目的地</span></span><br><span class="line"><span class="comment"> *   作用:创建一个FileWriter对象,创建一个</span></span><br><span class="line"><span class="comment"> *    1.创建一个FileWriter对象,构造方法中绑定写入的数据源</span></span><br><span class="line"><span class="comment"> *    2.使用FileWriter中的write()将数据写入到内存缓存区当中(字符转换为字节的过程)</span></span><br><span class="line"><span class="comment"> *    3.使用flush()将内存缓冲区中的内容刷新到文件中</span></span><br><span class="line"><span class="comment"> *    4.释放资源(会把内存缓冲区中的数据刷新到文件中)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"F:\\FileTest\\c.txt"</span>);</span><br><span class="line">        <span class="comment">//单个字符写</span></span><br><span class="line">        fw.write(<span class="number">97</span>);<span class="comment">//将数据写入到内存缓存区当中(字符-&gt;字节)</span></span><br><span class="line">        fw.flush();<span class="comment">//将缓冲中的数据存入硬盘</span></span><br><span class="line">        <span class="comment">//一次写一个字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] cs = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>&#125;;</span><br><span class="line">        fw.write(cs);</span><br><span class="line">        <span class="comment">//一次写字符数组的一部分</span></span><br><span class="line">        fw.write(cs, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//一次写一个字符串</span></span><br><span class="line">        fw.write(<span class="string">"你好哦哈哈哈"</span>);</span><br><span class="line">        <span class="comment">//一次写字符串的一部分</span></span><br><span class="line">        fw.write(<span class="string">"你好哦哈哈哈"</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//续写和换行,使用两个参数的构造方法,第二个参数为续写开关</span></span><br><span class="line">        FileWriter fw1 = <span class="keyword">new</span> FileWriter(<span class="string">"F:\\FileTest\\c.txt"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//换行写入 windows:\r\n   linux:/n   mac:/r</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            fw1.write(<span class="string">"梁清豪\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fw1.flush();</span><br><span class="line">        fw1.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h3><ul>
<li><p>在jdk1.7之前,可以使用try..catch..finally处理流中的异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.7之前需要用到两次try...catch...和判空语句</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将变量改为作用域改为全局,让变量能在finally中使用</span></span><br><span class="line">    <span class="comment">//若new的时候执行失败,则fw会没有值,fw.close()会报错,需将fw赋一个初值</span></span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//若执行失败,则fw会没有值,fw.close()会报错</span></span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(<span class="string">"F:\\FileTest\\c.txt"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            fw.write(<span class="string">"输入字符\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//close本身也有异常,故需要继续try..catch..</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//fw.close声明抛出了io异常,所以需要人为处理</span></span><br><span class="line">            <span class="comment">//若创建对象失败了,那么fw的默认值将是null,fw.close()会有空指针异常</span></span><br><span class="line">            <span class="comment">//需要加一条判断,若不为空,才执行fw.close()</span></span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fw.close();<span class="comment">//fw1变量出了大括号,作用域限制找不到fw1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jdk1.7新特性,可以省去finally中复杂的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JDk7的新特性在try的后边可以增加一个(),在括号中定义流对象</span></span><br><span class="line"><span class="comment"> * 那么这个流对象的作用域就在try中有效</span></span><br><span class="line"><span class="comment"> * try中的代码执行完毕,会自动把流对象释放,不用写finally</span></span><br><span class="line"><span class="comment"> * 格式try(定义流对象;可定义多个)&#123;</span></span><br><span class="line"><span class="comment"> *   会出异常的代码</span></span><br><span class="line"><span class="comment"> * &#125;catch&#123;</span></span><br><span class="line"><span class="comment"> *   异常处理的逻辑</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTryCatch7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> ( <span class="comment">//定义流对象;可定义多个,使用完毕会自动释放流对象</span></span><br><span class="line">              FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">              FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\m.txt"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//会出异常的代码</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//写入</span></span><br><span class="line">                fos.write(len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jdk1.9新特性,对1.7特性进行了改变,但用起来不如1.7,因为既得throws还得try…catch…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JDK9的新特性,</span></span><br><span class="line"><span class="comment"> *   在try的前边可以定义流对象</span></span><br><span class="line"><span class="comment"> *   在try的后边()中可以直接引入流对象的名称(变量名)</span></span><br><span class="line"><span class="comment"> *   在try代码执行完毕后,流对象也可以释放掉,不用写finally</span></span><br><span class="line"><span class="comment"> * 格式:</span></span><br><span class="line"><span class="comment"> *   A a = new a();</span></span><br><span class="line"><span class="comment"> *   B b = new b();</span></span><br><span class="line"><span class="comment"> *   try(a,b)&#123;</span></span><br><span class="line"><span class="comment"> *       会有异常的代码</span></span><br><span class="line"><span class="comment"> *   &#125;catch&#123;</span></span><br><span class="line"><span class="comment"> *       异常处理逻辑</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTryCatch9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//在try外定义流对象,但需要将此处异常抛出</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\m.txt"</span>);</span><br><span class="line">        <span class="keyword">try</span> ( <span class="comment">//传入流对象;可定是多个,使用完毕会自动释放流对象</span></span><br><span class="line">              fis,fos) &#123;</span><br><span class="line">            <span class="comment">//会出异常的代码</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//写入</span></span><br><span class="line">                fos.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="属性集-Properties"><a href="#属性集-Properties" class="headerlink" title="属性集  Properties"></a>属性集  Properties</h3><ul>
<li><p>Properties extends Hashtable&lt;k,v&gt;  是唯一与IO流相结合的集合</p>
</li>
<li><p>Properties 类表示了一个持久的属性集。可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</p>
</li>
<li><p>方法</p>
<ul>
<li>void load(Reader reader) <pre><code>按简单的面向行的格式从输入字符流中读取属性列表（键和元素对).字符输入流,能读取含有中文的中文键值对</code></pre></li>
<li>void load(InputStream inStream) <pre><code>从输入流中读取属性列表（键和元素对).字节输入流不能读取含有中文的键值对</code></pre></li>
<li>void store(OutputStream out, String comments) <pre><code>以适合使用 load(InputStream) 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。字节输出流不能写入中文. comments用来解释说明保存的文件是做什么用的,不能使用中文,默认是unicode编码,一般使用空字符串</code></pre></li>
<li>void store(Writer writer, String comments) <pre><code>以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符。 字符输出流能写入中文</code></pre></li>
<li>Object setProperty(String key, String value)     调用 Hashtable 的方法 put。 </li>
<li>String getProperty(String key)     通过key找到value值,相当于Map中的get(key) </li>
<li>Set&lt;String&gt;   stringPropertyNames() <pre><code>返回此属性列表中的键集，其中该键及其对应值是字符串，如果在主属性列表中未找到同名的键，则还包括默认属性列表中不同的键。 相当于map中的keySet()</code></pre></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Properties作用:</span></span><br><span class="line"><span class="comment">*   可以使用Properties集合中的方法store,把集合中的临时数据持久化写入到硬盘</span></span><br><span class="line"><span class="comment">*   可以使用Properties集合中的方法load,把硬盘中的数据读取到内存</span></span><br><span class="line"><span class="comment">* 属性列表中每个键及其对应值都是一个字符串: 是一个双列集合,key和value默认都是字符串</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProperties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 使用Properties存储数据,遍历取出Properties中的数据</span></span><br><span class="line"><span class="comment">    * Properties集合中有一些操作字符串的特有方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">        <span class="comment">//创建一个Properties集合对象</span></span><br><span class="line">        Properties prot = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//使用setProperty()往集合中添加数据</span></span><br><span class="line">        prot.setProperty(<span class="string">"赵丽颖"</span>,<span class="string">"168"</span>);</span><br><span class="line">        prot.setProperty(<span class="string">"迪丽热巴"</span>,<span class="string">"167"</span>);</span><br><span class="line">        prot.setProperty(<span class="string">"古力娜扎"</span>,<span class="string">"160"</span>);</span><br><span class="line">        <span class="comment">//使用stringPropertyNames(),将集合中的键值取出,返回到set集合中</span></span><br><span class="line">        Set&lt;String&gt; set = prot.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            <span class="comment">//通过key值获取value值</span></span><br><span class="line">            System.out.println(s+<span class="string">"-&gt;"</span>+prot.getProperty(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  store()持久化使用步骤:</span></span><br><span class="line"><span class="comment">         *  1.创建Properties集合对象,添加数据</span></span><br><span class="line"><span class="comment">         *  2.创建字节/字符输出流,其构造方法中绑定输出的目的地</span></span><br><span class="line"><span class="comment">         *  3.使用store()方法持久化到硬盘</span></span><br><span class="line"><span class="comment">         *  4.关闭流</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//创建字符输出流,</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">        <span class="comment">//store()方法持久化到硬盘,传入FileWriter对象和注释</span></span><br><span class="line">        prot.store(fw,<span class="string">"save Data"</span>);</span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.close();</span><br><span class="line">        <span class="comment">//使用字节流,匿名对象会自动关闭流,不用手动关闭</span></span><br><span class="line">        prot.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\a.txt"</span>,<span class="keyword">true</span>),<span class="string">"save"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  load()读取数据使用步骤:</span></span><br><span class="line"><span class="comment">         *  1.创建Properties集合对象,添加数据</span></span><br><span class="line"><span class="comment">         *  2.创建字节/字符输出流,其构造方法中绑定输入的源地</span></span><br><span class="line"><span class="comment">         *  3.使用load()方法读取数据到内存</span></span><br><span class="line"><span class="comment">         *  4.关闭流</span></span><br><span class="line"><span class="comment">         * 注意:</span></span><br><span class="line"><span class="comment">         *  1.文件中键值对默认的连接符号可以使用等号"="或者空格" ",或其他符号也可</span></span><br><span class="line"><span class="comment">         *  2.存储键值对的文件中,可以使用"#"注释,被注释的键值对不会再被读取</span></span><br><span class="line"><span class="comment">         *  3.存储键值对的文件中,默认都是字符串,不用再加引号</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        FileReader fw1 = <span class="keyword">new</span> FileReader(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">        prot.load(fw1);</span><br><span class="line">        <span class="comment">//再次提取key值</span></span><br><span class="line">        Set&lt;String&gt; set1 = prot.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set1) &#123;</span><br><span class="line">            System.out.println(s+<span class="string">"-&gt;"</span>+prot.getProperty(s));</span><br><span class="line">        &#125;</span><br><span class="line">        fw1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









</li>
</ul>
<h3 id="缓冲流Buffer"><a href="#缓冲流Buffer" class="headerlink" title="缓冲流Buffer"></a>缓冲流Buffer</h3><p>对基本的流进行一种增强</p>
<p>字节缓冲流: BufferedInputStream   BufferedOutputStream</p>
<p>字符缓冲流: BufferedReader BufferedWriter</p>
<ul>
<li><p>字节缓冲输入输出流 BufferedInputStream    BufferedOutputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BufferedOutputStream extends OutputStream</span></span><br><span class="line"><span class="comment">* 有继承自父类的共性成员方法</span></span><br><span class="line"><span class="comment">* 构造方法:</span></span><br><span class="line"><span class="comment">*   BufferedOutputStream(OutputStream out)</span></span><br><span class="line"><span class="comment">          创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</span></span><br><span class="line"><span class="comment">    BufferedOutputStream(OutputStream out, int size)</span></span><br><span class="line"><span class="comment">          创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。</span></span><br><span class="line"><span class="comment">    参数:OutputStream out 字节输出流,可以传递FileOutputStream,缓冲流会给传递的对象增加一个缓冲区,</span></span><br><span class="line"><span class="comment">*       int size 指定缓冲流内部缓冲区大小,不指定为默认大小</span></span><br><span class="line"><span class="comment">* 使用步骤:</span></span><br><span class="line"><span class="comment">*   1.创建一个FileOutputStream对象,构造方法绑定目的地</span></span><br><span class="line"><span class="comment">*   2.创建BufferedOutputStream对象,构造方法传递FileOutputStream对象</span></span><br><span class="line"><span class="comment">*   3.使用BufferedOutputStream对象中的write方法,把数据缓冲到内存缓冲区</span></span><br><span class="line"><span class="comment">*   4.使用flush(),把内部缓冲区数据输出到目的地</span></span><br><span class="line"><span class="comment">*   5.释放资源,调用close()方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">    bos.write(<span class="string">"我把数据写入到内部缓冲区中"</span>.getBytes());</span><br><span class="line">    bos.flush();</span><br><span class="line">    bos.close();<span class="comment">//关闭缓冲流会自动关闭基本的字节流不用fos.close()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 与BufferedOutputStream基本相同</span></span><br><span class="line"><span class="comment">* BufferedInputStream extends InputStream</span></span><br><span class="line"><span class="comment">* 有继承自父类的共性成员方法</span></span><br><span class="line"><span class="comment">* 构造方法:</span></span><br><span class="line"><span class="comment">*  BufferedInputStream(InputStream in)</span></span><br><span class="line"><span class="comment">          创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</span></span><br><span class="line"><span class="comment">   BufferedInputStream(InputStream in, int size)</span></span><br><span class="line"><span class="comment">          创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</span></span><br><span class="line"><span class="comment">    参数:InputStream in 字节输入流,可以传递FileInputStream,缓冲流会给传递的对象增加一个缓冲区</span></span><br><span class="line"><span class="comment">*       int size 指定缓冲流内部缓冲区大小,不指定为默认大小</span></span><br><span class="line"><span class="comment">* 使用步骤:</span></span><br><span class="line"><span class="comment">*   1.创建一个FileInputStream对象,构造方法绑定目的地</span></span><br><span class="line"><span class="comment">*   2.创建BufferedInputStream对象,构造方法传递FileInputStream对象</span></span><br><span class="line"><span class="comment">*   3.使用BufferedInputStream对象中的read方法,把数据缓冲到内部缓冲区</span></span><br><span class="line"><span class="comment">*   4.释放资源,调用close()方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\FileTest\\a.txt"</span>);</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int read = 0;</span></span><br><span class="line"><span class="comment">    while((read=bis.read())!=-1) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println((char)read);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//存储每次读取的数据</span></span><br><span class="line">    <span class="keyword">int</span> read =<span class="number">0</span>;<span class="comment">//记录每次读取的有效字节个数</span></span><br><span class="line">    <span class="keyword">while</span>((read=bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">    &#125;</span><br><span class="line">    bis.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符缓冲输入输出流: BufferedReader BufferedWriter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BufferWriter extends Writer</span></span><br><span class="line"><span class="comment">* 有继承自父类的共性成员方法</span></span><br><span class="line"><span class="comment">* 构造方法:</span></span><br><span class="line"><span class="comment">*   BufferedWriter(Writer out)</span></span><br><span class="line"><span class="comment">          创建一个使用默认大小输出缓冲区的缓冲字符输出流。</span></span><br><span class="line"><span class="comment">    BufferedWriter(Writer out, int sz)</span></span><br><span class="line"><span class="comment">          创建一个使用给定大小输出缓冲区的新缓冲字符输出流。</span></span><br><span class="line"><span class="comment">    参数:Writer out 字符输出流,可以传递FileWriter,缓冲流会给传递的对象增加一个缓冲区</span></span><br><span class="line"><span class="comment">*       int sz 指定缓冲流内部缓冲区大小,不指定为默认大小</span></span><br><span class="line"><span class="comment">* 特有的成员方法:void newLine()  写入一个行分隔符。会根据不同的操作系统获取不同的行分割符</span></span><br><span class="line"><span class="comment">* 使用步骤:</span></span><br><span class="line"><span class="comment">*   1.创建一个FileWriter对象,构造方法绑定目的地</span></span><br><span class="line"><span class="comment">*   2.创建BufferedWriter对象,构造方法传递FileWriter对象</span></span><br><span class="line"><span class="comment">*   3.使用BufferedWriter对象中的write方法,把数据缓冲到内存缓冲区</span></span><br><span class="line"><span class="comment">*   4.使用flush(),把内存缓冲区数据输出到目的地</span></span><br><span class="line"><span class="comment">*   5.释放资源,调用close()方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"F:\\FIleTest\\a.txt"</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        bw.write(<span class="string">"数据缓冲到内存"</span>+i);</span><br><span class="line">        <span class="comment">//换行方法</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">    bw.flush();</span><br><span class="line">    bw.close();</span><br><span class="line">    method();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 与BufferReader基本相同</span></span><br><span class="line"><span class="comment">* BufferReader extends Reader</span></span><br><span class="line"><span class="comment">* 有继承自父类的共性成员方法</span></span><br><span class="line"><span class="comment">* 构造方法:</span></span><br><span class="line"><span class="comment">*  BufferedReader(Reader in)</span></span><br><span class="line"><span class="comment">      创建一个使用默认大小输入缓冲区的缓冲字符输入流。</span></span><br><span class="line"><span class="comment">   BufferedReader(Reader in, int sz)</span></span><br><span class="line"><span class="comment">      创建一个使用指定大小输入缓冲区的缓冲字符输入流。</span></span><br><span class="line"><span class="comment">    参数:Reader in 字符输入流,可以传递FileReader,缓冲流会给传递的对象增加一个缓冲区</span></span><br><span class="line"><span class="comment">      int size 指定缓冲流内存缓冲区大小,不指定为默认大小</span></span><br><span class="line"><span class="comment">* 特有的成员方法:</span></span><br><span class="line"><span class="comment">* 使用步骤: String readLine() 读取一行数据,不包含终止符号,达到流的末尾返回null</span></span><br><span class="line"><span class="comment">*       行的终止符号 \r  \n  或回车之后跟着换行</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   1.创建一个FileReader对象,构造方法绑定目的地</span></span><br><span class="line"><span class="comment">*   2.创建BufferedReader对象,构造方法传递FileReader对象</span></span><br><span class="line"><span class="comment">*   3.使用BufferedReader对象中的read/readLine方法,把数据缓冲到内存缓冲区</span></span><br><span class="line"><span class="comment">*   4.释放资源,调用close()方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F:\\FileTest\\a.txt"</span>));</span><br><span class="line">    String s = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//循环读取每一个整行,结束条件为读取到null的时候</span></span><br><span class="line">    <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符缓冲练习,文本排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.使用HashMap key存出每行文本的序号,value存储每行文版</span></span><br><span class="line"><span class="comment"> * 2.创建字符缓冲输入流,构造方法中绑定字符输入流</span></span><br><span class="line"><span class="comment"> * 3.创建字符缓冲输出流,构造方法中绑定字符输出流</span></span><br><span class="line"><span class="comment"> * 4.使用字符缓冲输入流中的readLine()逐行读取文本</span></span><br><span class="line"><span class="comment"> * 5.对读取到的文本进行切割,获取行序号和文本内容</span></span><br><span class="line"><span class="comment"> * 6.把读取到的序号(key)和文本内容(value)存储到HashMap集合中,会按照序号自动排序</span></span><br><span class="line"><span class="comment"> * 7.遍历HashMap集合,获取每一个键值对</span></span><br><span class="line"><span class="comment"> * 8.把每一个键值对拼接为一个文本行</span></span><br><span class="line"><span class="comment"> * 9.把拼接好的每一个文本使用字符缓冲输出流中的write,写入到文件中</span></span><br><span class="line"><span class="comment"> * 10.释放资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F:\\FileTest\\a.txt"</span>));</span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"F:\\FileTest\\b.txt"</span>));</span><br><span class="line">    String line;</span><br><span class="line">    <span class="comment">//将文件中内容读出,按照"."分割,并存入HashMap中</span></span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] arr = line.split(<span class="string">"\\."</span>);</span><br><span class="line">        map.put(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将HashMap中的东西读出来并写入新文件</span></span><br><span class="line">    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        String value = map.get(key);</span><br><span class="line">        line = key + <span class="string">"."</span> + value;</span><br><span class="line">        bw.write(line);</span><br><span class="line">        <span class="comment">//写换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">    bw.close();</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="转换流-InputStreamReader-OutputStreamWriter"><a href="#转换流-InputStreamReader-OutputStreamWriter" class="headerlink" title="转换流 InputStreamReader  OutputStreamWriter"></a>转换流 InputStreamReader  OutputStreamWriter</h3><p>可以指定编码表,读取/写入任意格式的文件</p>
<p>编码: 按照某种规则,将字符存储到计算机中,称之为编码</p>
<p>解码: 将计算机中的二进制数按照某种规则,转换为字符,称为解码</p>
<p>字符集: 也叫编码表,是一个系统支持的所有字符的集合,包含各个国家文字,标点符号,图形符号,数字等,是一个生活中的文字和计算机二进制的对应规则</p>
<p>FileReader只能读取IDE默认编码格式的文件,若读取其他编码格式文件,会出现乱码</p>
<ul>
<li><p>InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* OutputStreamWriter extends Writer</span></span><br><span class="line"><span class="comment">* 字符通向字节的桥梁,可以指定编码表</span></span><br><span class="line"><span class="comment">* 有继承自父类的共性方法</span></span><br><span class="line"><span class="comment">* 构造方法:</span></span><br><span class="line"><span class="comment">*   OutputStreamWriter(OutputStream out)</span></span><br><span class="line"><span class="comment">          创建使用默认字符编码的 OutputStreamWriter。</span></span><br><span class="line"><span class="comment">    OutputStreamWriter(OutputStream out, String charsetName)</span></span><br><span class="line"><span class="comment">          创建使用指定字符集的 OutputStreamWriter。</span></span><br><span class="line"><span class="comment">*   参数:</span></span><br><span class="line"><span class="comment">*       OutputStream out 字节输出流,用来将转换之后的字节输出到文件</span></span><br><span class="line"><span class="comment">*       String charsetName  编码表名称,不区分大小写,不知道默认使用IED的编码</span></span><br><span class="line"><span class="comment">* 使用步骤:</span></span><br><span class="line"><span class="comment">*   1.创建OutputStreamWriter,构造方法中传入字节输出流对象和指定的编码表名称</span></span><br><span class="line"><span class="comment">*   2.使用OutputStreamWriter中的方法writer(),把字符转换为字节存储到内存中</span></span><br><span class="line"><span class="comment">*   3.使用OutputStreamWriter中的方法flush(),将内存中数据刷新到文件中</span></span><br><span class="line"><span class="comment">*   4.释放资源</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//第二个参数指定编码格式</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\utf_8.txt"</span>), <span class="string">"utf-32"</span>);</span><br><span class="line">        osw.write(<span class="string">"你好"</span>);</span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* InputStreamReader extends Reader</span></span><br><span class="line"><span class="comment">* 字符通向字节的桥梁,可以指定编码表</span></span><br><span class="line"><span class="comment">* 有继承自父类的共性方法</span></span><br><span class="line"><span class="comment">* 构造方法:</span></span><br><span class="line"><span class="comment">*   InputStreamReader(InputStream in)</span></span><br><span class="line"><span class="comment">          创建一个使用默认字符集的 InputStreamReader。</span></span><br><span class="line"><span class="comment">    InputStreamReader(InputStream in, String charsetName)</span></span><br><span class="line"><span class="comment">          创建使用指定字符集的 InputStreamReader。</span></span><br><span class="line"><span class="comment">*   参数:</span></span><br><span class="line"><span class="comment">*       InputStream in 字节输入流,用来读取文件中保存的字节到内存</span></span><br><span class="line"><span class="comment">*       String charsetName  编码表名称,不区分大小写,不知道默认使用IED的编码</span></span><br><span class="line"><span class="comment">* 使用步骤:</span></span><br><span class="line"><span class="comment">*   1.创建InputStreamReader,构造方法中传入字节输入流对象和指定的编码表名称</span></span><br><span class="line"><span class="comment">*   2.使用InputStreamReader中的方法read(),把字符转换为字节存储到从文件中读取到内存</span></span><br><span class="line"><span class="comment">*   4.释放资源</span></span><br><span class="line"><span class="comment">* 注意:构造方法中,指定的编码格式要与文件编码相同,否则乱码</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\FileTest\\utf_8.txt"</span>), <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习:转换文件编码</p>
<ul>
<li><p>将GBK编码的文本文件,转换为UTF-8文本文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.创建InputStreamReader对象,构造方法传递字节输入流,读取格式为"GBK"</span></span><br><span class="line"><span class="comment"> * 2.创建OutputStreamWriter对象,构造方法传递字节输出流,写格式为"UTF-8"</span></span><br><span class="line"><span class="comment"> * 3.将read()读的数据用writer()写入文件</span></span><br><span class="line"><span class="comment"> * 4.释放资源</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\FileTest\\a.txt"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\d.txt"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">//准备一个字符数组将读取到的字符存入其中</span></span><br><span class="line">    <span class="keyword">char</span>[] read = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> Length;<span class="comment">//接收读取到数据的有效长度,-1结束</span></span><br><span class="line">    <span class="keyword">while</span> ((Length = isr.read(read)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        osw.write(read, <span class="number">0</span>, Length);</span><br><span class="line">    &#125;</span><br><span class="line">    osw.flush();</span><br><span class="line">    osw.close();</span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>对象的序列化: 把对象以流的形式,写入到文件中保存,叫写对象,也叫对象的序列化,对象中包含的不仅仅式字符,故使用字节流. ObjectOutputStream: 对象的序列化流 使用writeObject(对象名)方法</p>
<p>对象的反序列化: 把文件中保存的对象,以流的方式读取出来,叫做读对象,也叫反序列化,读取的文件保存的都是字节,故使用字节流. ObjectInputStream: 对象的反序列化流 使用readObject(对象名)方法</p>
<ul>
<li><p>ObjectOutputStream 序列化流</p>
</li>
<li><p>ObjectInputStream 反序列化流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ObjectOutputStream extends OutputStream</span></span><br><span class="line"><span class="comment">* 把对象以流的形式写入到文件中</span></span><br><span class="line"><span class="comment">* 注意:</span></span><br><span class="line"><span class="comment">*   对象序列化和反序列化时必须实现Serializable接口,以启动序列化,会给类添加一个标记,当序列化时,就会检测类中是否有这个标记,如果有就会正常进行,若没有就会有异常</span></span><br><span class="line"><span class="comment">* 构造方法:</span></span><br><span class="line"><span class="comment">*   ObjectOutputStream(OutputStream out)</span></span><br><span class="line"><span class="comment">          创建写入指定 OutputStream 的 ObjectOutputStream。</span></span><br><span class="line"><span class="comment">*   参数: OutputStream out 传入一个字节输出流</span></span><br><span class="line"><span class="comment">*特有的成员方法:</span></span><br><span class="line"><span class="comment">*   void writeObject(Object obj)   将指定的对象写入 ObjectOutputStream。</span></span><br><span class="line"><span class="comment">* 使用步骤:</span></span><br><span class="line"><span class="comment">*   1.创建ObjectOutputStream对象,构造方法中传递字节输出流</span></span><br><span class="line"><span class="comment">*   2.使用writeObject()将对象写入文件</span></span><br><span class="line"><span class="comment">*   3.释放资源</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\d.txt"</span>));</span><br><span class="line">    Person p = <span class="keyword">new</span> Person(<span class="string">"赵丽颖"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    oos.writeObject(p);<span class="comment">//NotSerializableException未序列化异常</span></span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* ObjectInputStream extends InputStream</span></span><br><span class="line"><span class="comment">* 把文件中的对象读入到内存</span></span><br><span class="line"><span class="comment">* 注意:</span></span><br><span class="line"><span class="comment">*   反序列化时必须实现Serializable接口,以启动序列化,会给类添加一个标记,当序列化时,就会检测类中是否有这个标记,如果有就会正常进行,若没有就会有异常</span></span><br><span class="line"><span class="comment">*   对象的反序列化还有类找不到异常,必须声明处理ClassNotFoundException异常</span></span><br><span class="line"><span class="comment">* 构造方法:</span></span><br><span class="line"><span class="comment">*   ObjectInputStream(InputStream in)</span></span><br><span class="line"><span class="comment">          创建从指定 InputStream 读取的 ObjectInputStream。</span></span><br><span class="line"><span class="comment">*   参数: InputStream in 传入一个字节输入流</span></span><br><span class="line"><span class="comment">*特有的成员方法:</span></span><br><span class="line"><span class="comment">*   Object readObject()    从 ObjectInputStream 读取对象。</span></span><br><span class="line"><span class="comment">*       该方法会有类找不到异常,必须有返回的类才能被读取</span></span><br><span class="line"><span class="comment">* 使用步骤:</span></span><br><span class="line"><span class="comment">*   1.创建ObjectInputStream对象,构造方法中传递字节输入流</span></span><br><span class="line"><span class="comment">*   2.使用readObject()将对象读入内存</span></span><br><span class="line"><span class="comment">*   3.释放资源</span></span><br><span class="line"><span class="comment">*   4.使用读取处理的对象,例如直接打印</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\FileTest\\d.txt"</span>));</span><br><span class="line">    Object o = ois.readObject();<span class="comment">//会有ClassNotFoundException类找不到异常</span></span><br><span class="line">    <span class="comment">//可以强转为Person类型</span></span><br><span class="line">    Person  p = (Person) o;</span><br><span class="line">    ois.close();</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接实现Serializable接口即可,该接口只是标记,无须重写任何方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">42L</span>;<span class="comment">//序列号问题</span></span><br><span class="line">	<span class="comment">//需写构造方法和重写toString() 此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>transient 瞬态关键字</strong></p>
<ul>
<li>static 静态优先于非静态加载到内存中,被static修饰的成员变量时不能被序列化的,序列化的都是对象,而静态不属于对象,是属于类的,序列化时就不会将静态的变量序列化</li>
<li>transient 被transient 修饰的成员变量同样也不能被序列化,同时被transient修饰的关键字也不是静态的.</li>
</ul>
</li>
<li><p><strong>反序列化可能存在的问题</strong></p>
<ul>
<li>序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：<code>static final long serialVersionUID = 42L;</code></li>
</ul>
</li>
<li><p>练习:序列化集合,往文件中保存多个对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 练习:序列化集合</span></span><br><span class="line"><span class="comment"> *   当我们想在文件中保存多个对象的时候</span></span><br><span class="line"><span class="comment"> *   可以把多个对象存储到一个集合中</span></span><br><span class="line"><span class="comment"> *   对集合进行序列化和反序列化</span></span><br><span class="line"><span class="comment"> * 分析:</span></span><br><span class="line"><span class="comment"> *   1.定义一个存储Person对象的ArrayList集合</span></span><br><span class="line"><span class="comment"> *   2.往ArrayList集合中存储Person对象</span></span><br><span class="line"><span class="comment"> *   3.创建一个序列化流ObjectOutputStream</span></span><br><span class="line"><span class="comment"> *   4.ObjectOutputStream中的writeObject()对集合进行序列化</span></span><br><span class="line"><span class="comment"> *   5.创建ObjectInputStream</span></span><br><span class="line"><span class="comment"> *   6.使用ObjectInputStream中的readObject()对集合进行反序列化</span></span><br><span class="line"><span class="comment"> *   7.把Object类型的集合转换为ArrayList集合</span></span><br><span class="line"><span class="comment"> *   8.遍历ArrayList集合</span></span><br><span class="line"><span class="comment"> *   9.释放资源</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.定义一个存储Person对象的ArrayList集合</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.往ArrayList集合中存储Person对象</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"赵丽颖"</span>, <span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"杨颖"</span>, <span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>, <span class="number">20</span>));</span><br><span class="line">        <span class="comment">//3.创建一个序列化流ObjectOutputStream</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\FileTest\\list.txt"</span>));</span><br><span class="line">        <span class="comment">//4.ObjectOutputStream中的writeObject()对集合进行序列化</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        <span class="comment">//6.使用ObjectInputStream中的readObject()对集合进行反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\FileTest\\list.txt"</span>));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        <span class="comment">//7.把读出的Object类型的集合转换为ArrayList集合</span></span><br><span class="line">        ArrayList&lt;Person&gt; list1 = (ArrayList&lt;Person&gt;) o;</span><br><span class="line">        <span class="comment">//8.遍历ArrayList集合</span></span><br><span class="line">        <span class="keyword">for</span> (Person person : list1) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//9.释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><ul>
<li><p>System.out.println()  out其实就是一个打印流, println()是打印流里面的方法</p>
</li>
<li><pre><code class="java"><span class="comment">/*</span>
<span class="comment">* java.io.PrintStream: 打印流</span>
<span class="comment">* PrintStream extends OutputStream 有继承自父类的成员方法</span>
<span class="comment">*   PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</span>
<span class="comment">* 特定:</span>
<span class="comment">*   1.只负责数据的输出,不负责数据的读入</span>
<span class="comment">*   2.与其他输出流不同，PrintStream 永远不会抛出 IOException</span>
<span class="comment">*   3.有特有的方法print,println 输出任意类型的值</span>
<span class="comment">* 构造方法:输出的目的地可以是文件,字节输出流,文件路径</span>
<span class="comment">*   PrintStream(File file)</span>
<span class="comment">    PrintStream(OutputStream out)</span>
<span class="comment">    PrintStream(String fileName)</span>
<span class="comment">* 注意:</span>
<span class="comment">*   如果使用继承自父类的writer()方法写数据,那么查看数据的时候会查询编码表 97-&gt;a</span>
<span class="comment">*   如果使用特有方法print()写数据,写的数据原样输出 97-&gt;97</span>
<span class="comment">* */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrintStream</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>{
        <span class="comment">//创建一个打印流,构造方法中绑定目的地,抛出的是文件找不到异常,不会有IO异常</span>
        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"F:\\FileTest\\print.txt"</span>);
        <span class="comment">//97-&gt;a</span>
        ps.write(<span class="number">97</span>);
        <span class="comment">//97-&gt;97,可以传递任意数据类型的值</span>
        ps.println(<span class="number">97</span>);
        <span class="comment">//使用System中的static void setOut(PrintStream out)方法</span>
        <span class="comment">//改变输出语句打印流的目的地为参数</span>
        System.out.println(<span class="string">"我是在控制台输出的"</span>);
        <span class="comment">//将输出语句的目的地改为打印流的目的地</span>
        System.setOut(ps);
        System.out.println(<span class="string">"此时我实在指定的目的地输出的"</span>);
        ps.close();

    }
}</code></pre>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">laden</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lqhao.gitee.io/2020/07/18/1/">http://lqhao.gitee.io/2020/07/18/1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lqhao.gitee.io" target="_blank">不蒸馒头争口气</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/FIle/">FIle</a><a class="post-meta__tags" href="/tags/IO/">IO</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/weixinpay.jpg" alt="微信" onclick="window.open('https://gitee.com/lqhao/img-bed/raw/master/img-page/weixinpay.jpg')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://gitee.com/lqhao/img-bed/raw/master/img-page/alipay.jpg" alt="支付宝" onclick="window.open('https://gitee.com/lqhao/img-bed/raw/master/img-page/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/19/1/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java-网络编程</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/15/3/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java-Lambda表达式</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/25/2/" title="Java-JDBC连接池、JDBCTemplate"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-25</div><div class="relatedPosts_title">Java-JDBC连接池、JDBCTemplate</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/08/1/" title="Java-API-说明文档推荐"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-08</div><div class="relatedPosts_title">Java-API-说明文档推荐</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/20/2/" title="Java-Stream流"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-20</div><div class="relatedPosts_title">Java-Stream流</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By laden</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>